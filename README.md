# Windows_Malware_Emulator


![logo](./WMElogo.png)


## Introduction


WME (short for Windows_Malware_Emulator) is a standalone PE emulator written in Python3 with a primary focus on malware analysis.


This project aims to provide a standalone script to run malicious PE without any externals dependencies.


It also provides foundation for binaries that require some exotic setup or specific API returns value.


WME does not have any hardware dependencies nor any Windows internal files to works.




Project still in development and subject to major modifications.


Tested with a limited subset of malware, including: WannaCry dropper & payload, phorpiex, Sodinokibi, dexter POS, Pony, DiamondFox, Emotet, Practical Malware nalysis samples, and more.


Support for UPX standard unpacking.


Used in the Cerberus Sandbox project as the main emulation engine.



## Functionalities


* Ability to search memory locations for unpacked/additional PE.

* Ability to keep track of dynamically resolved API.

* Ability to keep track of dynamically resolved/decrypted strings.

* Ability to differentiate stdcall and cdecl calling conventions.

* Ability to track open handles and their values.

* Silent or verbose mode for a focus on the assembly level, or only on the Windows API level.

* Ability to easily register new API and/or instrument them in your own way.

* Ability to act as a debugger with a single-step feature with a highlight in stack and register changes.

* Ability to execute threads/childs process.

* Detection of infinite code loops.

* Ability to blackist process names checked by anti-debug routines.

* Ability to blackist DLL names related to security products checked by anti-analysis routines.

* Ability to blackist file names related to security products checked by anti-analysis routines.

* Memory manager with a fully emulated heap management.

* Ability to resolve functions pointers (which is not natively supported by Unicorn).

* Ability to emulate the Thread Information Block (TIB) and a part of the Process Information Block (PEB)

* Reimplementation of 146 Windows API. In constant evolution.


Does not support .NET binaries


## Usage

```python3
[root@Arch Windows_Malware_Emulator]# python3 emulator.py -h
usage: emulator.py [-h] -p PATH [-b BREAKPOINT] [--trace] [--dump] [--stack] [--registers] [--debug] [--silent] [--handle] [--extract] [--strings] [--imports] [--dynamics]
                   [--out OUT]

Windows Binary Emulator

optional arguments:
  -h, --help            show this help message and exit
  -p PATH, --path PATH  path to the binary file to emulate
  -b BREAKPOINT, --breakpoint BREAKPOINT
                        pause the execution at the given address
  --trace               display the call trace of the binary
  --dump                display a full dump of the program's state after the execution
  --stack               display a dump of the stack after the execution
  --registers           display a dump of the regsiters after the execution
  --debug               display debug messages
  --silent              only print out the system calls
  --handle              display the list of used handles
  --extract             extract potentials payloads found in memory. Files are saved to <bin_name>_emu.out/
  --strings             extract a list of strings observed during the emulation
  --imports             UNIMPLEMENTED - display the static content of the import address table (IAT)
  --dynamics            display the list of dynamically resolved syscall
  --out OUT             save the emulation output to a file
```

## Exemple

* WannaCry core payload command execution and API resolving :
```
[...]
> 0x401dc3: (_stdcall) FindResourceA(hModule="wannacry_payload", lpName=2058, lpType=0x40f43c) = 0xac
> 0x401dd3: (_stdcall) LoadResource(hModule="wannacry_payload", hResInfo=0xac) = 0x60001000
> 0x401dde: (_stdcall) LockResource(hResData=0x60001000) = 0x60001000
> 0x401df1: (_stdcall) SizeofResource(hModule="wannacry_payload", hResInfo=0xac) = 0x349635
> 0x407700: (_cdecl  ) ??2@YAPAXI@Z() = 0x0
> 0x40101b: (_stdcall) fopen() = 0x0
> 0x4010a8: (_stdcall) CreateProcessA(lpApplicationName=0x0, lpCommandLine="attrib +h .", lpProcessAttributes=0x0, lpThreadAttributes=0x0, bInheritHandles=0x0, dwCreationFlags=CREATE_NO_WINDOW, lpEnvironment=0x0, lpCurrentDirectory=0x0, lpStartupInfo=0x1ff100, lpProcessInformation=0x1ff144) = 0x1
> 0x4010ec: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x4010f1: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x4010a8: (_stdcall) CreateProcessA(lpApplicationName=0x0, lpCommandLine="icacls . /grant Everyone:F /T /C /Q", lpProcessAttributes=0x0, lpThreadAttributes=0x0, bInheritHandles=0x0, dwCreationFlags=CREATE_NO_WINDOW, lpEnvironment=0x0, lpCurrentDirectory=0x0, lpStartupInfo=0x1ff0f4, lpProcessInformation=0x1ff138) = 0x1
> 0x4010ec: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x4010f1: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x401a5a: (_stdcall) LoadLibraryA(lpLibFileName="advapi32.dll") = 0xb1
> 0x401a77: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptAcquireContextA") = 0xdf62
> 0x401a84: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptImportKey") = 0xdf66
> 0x401a91: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptDestroyKey") = 0xdf6a
> 0x401a9e: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptEncrypt") = 0xdf6e
> 0x401aab: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptDecrypt") = 0xdf72
> 0x401ab8: (_stdcall) GetProcAddress(hModule=hadvapi32.dll, lpProcName="CryptGenKey") = 0xdf76

```


* WannaCry droper resource extraction
```
[...]
> 0x407c68: (_stdcall) OpenSCManagerA(lpMachineName=LOCAL_COMPUTER, lpDatabaseName=SERVICE_ACTIVE_DATABASE, dwDesiredAccess=0xf003f) = 0xae
> 0x407c9b: (_stdcall) CreateServiceA(hSCManager=hSERVICE_ACTIVE_DATABASE, lpServiceName="mssecsvc2.0", lpDisplayName="Microsoft Security Center (2.0) Service", dwDesiredAccess=0xf01ff, dwServiceType=SERVICE_WIN32_OWN_PROCESS, dwStartType=SERVICE_AUTO_START, dwErrorControl=SERVICE_ERROR_NORMAL, lpBinaryPathName="", lpLoadOrderGroup=0x0, lpdwTagId=0x0, lpDependencies=0x0, lpServiceStartName=0x0, lpPassword=0x0) = 0xaf
> 0x407cb2: (_stdcall) StartServiceA(hService=hmssecsvc2.0, dwNumServiceArgs=0x0, lpServiceArgVector=0x0) = 0x1
> 0x407cb9: (_stdcall) CloseServiceHandle(hSCObject=hmssecsvc2.0) = 0x2
> 0x407cbc: (_stdcall) CloseServiceHandle(hSCObject=hSERVICE_ACTIVE_DATABASE) = 0x2
> 0x407cef: (_stdcall) GetModuleHandleW(lpModuleName="kernel32.dll") = 0xb0
> 0x407d0d: (_stdcall) GetProcAddress(hModule=hkernel32.dll, lpProcName="CreateProcessA") = 0x80000077
> 0x407d1a: (_stdcall) GetProcAddress(hModule=hkernel32.dll, lpProcName="CreateFileA") = 0x8000007b
> 0x407d27: (_stdcall) GetProcAddress(hModule=hkernel32.dll, lpProcName="WriteFile") = 0x8000007f
> 0x407d34: (_stdcall) GetProcAddress(hModule=hkernel32.dll, lpProcName="CloseHandle") = 0x80000083
> 0x407d74: (_stdcall) FindResourceA(hModule="wannacry_droper", lpName=1831, lpType=0x43137c) = 0xb1
> 0x407d86: (_stdcall) LoadResource(hModule="wannacry_droper", hResInfo=0xb1) = 0x60001000
> 0x407d95: (_stdcall) LockResource(hResData=0x60001000) = 0x60001000
> 0x407da9: (_stdcall) SizeofResource(hModule="wannacry_droper", hResInfo=0xb1) = 0x35a000
> 0x407e01: (_cdecl  ) sprintf() = 0x0
> 0x407e18: (_cdecl  ) sprintf() = 0x0
> 0x407e2c: (_stdcall) MoveFileExA(0x1ff5ec, 0x1ff6f0, 0x1) = 0x0
> 0x407e43: (_stdcall) CreateFileA(lpFileName="", dwDesiredAccess=0x40000000, dwShareMode=BLOCK_MODE, lpSecurityAttributes=0x0, dwCreationDisposition=CREATE_ALWAYS, dwFlagsAndAttributes=0x4, hTemplateFile=0x0) = 0xb2
> 0x407e61: (_stdcall) WriteFile(hFile="h", lpBuffer=0x60001000, nNumberOfBytesToWrite=0x35a000, lpNumberOfBytesWritten=0x1ff594, lpOverlapped=0x0) = 0x1
> 0x407e68: (_stdcall) CloseHandle(hObject=h) = 0x2
> 0x407ee8: (_stdcall) CreateProcessA(lpApplicationName=0x0, lpCommandLine=" /i", lpProcessAttributes=0x0, lpThreadAttributes=0x0, bInheritHandles=0x0, dwCreationFlags=CREATE_NO_WINDOW, lpEnvironment=0x0, lpCurrentDirectory=0x0, lpStartupInfo=0x1ff5a8, lpProcessInformation=0x1ff598) = 0x1
> 0x407ef7: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x407f02: (_stdcall) CloseHandle(hObject=h0x0) = 0x2
> 0x409b4e: (_stdcall) exit(0x0)

======= Extracted Payloads =======
Name="" Content="bytearray(b'MZ\x90\x00\x0[...]xc2\x03')" (PE payload detected)

```

* Breakpoint usage
```
python3 emulator.py -p /opt/Samples/diamondfox_3.bin -b 0x420722
[...]
> Tracing intruction 0x420713 : push ecx
> Tracing intruction 0x420714 : call diamondfox_3.0x40a54d
> Following function diamondfox_3.0x40a54d:
> Tracing intruction 0x40a54d : jmp dword ptr [&malloc]
> 0x40a54d: (_stdcall) malloc(size=0x22) = 0x6004d000
> Tracing intruction 0x420719 : mov edi, eax
> Tracing intruction 0x42071b : add esp, 4
> Tracing intruction 0x42071e : test edi, edi
> Tracing intruction 0x420720 : je 0x420744

Registers:					Stack:
 EAX: 0x6004d000 | EBP: 0x00000012		0x001ff868: 0x00000000
 EBX: 0x00000021 | ESP: 0x001ff868		0x001ff86c: 0x6004a000
 ECX: 0x00000022 | ESI: 0x60047000		0x001ff870: 0x00430d70
 EDX: 0x60047002 | EDI: 0x6004d000		0x001ff874: 0x60047000
						                0x001ff878: 0x0040f178
 EIP: 0x00420724  (Breakpoint hit)		0x001ff87c: 0x60047000


 [s] Single step (default) / [c] Continue / [e] Exit  > 
--------------------------------------------------------------
```

