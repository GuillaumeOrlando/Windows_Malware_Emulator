from unicorn import *
from unicorn.x86_const import *
from capstone import *
from importlib import import_module
from syscall import clean_stack
import argparse
import syscall as winsyscall
import pefile
import struct
import sys
import ast

#TODO: Deal with SEH structure
#TODO: Randomize TEB base address
#TODO: Randomize process ID
#TODO: Randomize thread ID
#TODO: Heap management
#TODO: Vmem management
#TODO: Process management
#TODO: Thread management

API_refs = 'winapi_9k.csv'
regs = ['eax', 'ebx', 'ecx', 'edx', 'esp', 'ebp', 'edi', 'esi']

md = Cs(CS_ARCH_X86, CS_MODE_32)


class Environment:

    def __init__(self, args):
        # Argument validation
        self.breakpoint = args.breakpoint
        self.trace = args.trace
        self.dump = args.dump
        self.silent = args.silent
        self.out = args.out
        self.stack = args.stack
        self.registers = args.registers
        self.debug = args.debug
        self.handle_list = args.handle
        self.imports = args.imports
        self.dynamics = []
        if self.trace:
            self.calltrace = []
        if self.stack and self.registers:
            self.dump = True
        if self.dump:
            self.registers = True
            self.stack = True

        path = args.path
        self.shortname = path.split('/')[-1].split('.')[0].lower()
        self.drivename = 'C:\\Users\\EllenRipley\\Desktop\\' + self.shortname
        self.computername = 'Nostromo'
        self.computer_mac = '0F-0C-95-86-20-29'
        self.computer_ip = '192.168.0.12'
        self.path = path
        self.uc = Uc(UC_ARCH_X86, UC_MODE_32)
        # Init the handler list with a static fixed dummy value
        self.handle = {'0xaa': ['placeholder_dynamic_handle', 'dummy']}
        try:
            self.pe = pefile.PE(path)
        except OSError as e:
            print(e)
            exit -1
        except pefile.PEFormatError as e:
            print(f'Malformated or invalid PE file: {e.value}')
            exit -1
    
    # Log every instruction emulated
    def hook_code(self, a, address, size, user_data):
        instruction = self.uc.mem_read(address, size)

        # Manual Breakpoint
        if self.breakpoint:
            if hex(address) == self.breakpoint:
                final_esp = self.uc.reg_read(UC_X86_REG_ESP)
                final_ebp = self.uc.reg_read(UC_X86_REG_EBP)
                self.uc.emu_stop()
                self.calltrace.append('breakpoint')
                print('[+] Breakpoint hits at 0x%08x' % int(self.breakpoint, 16))
                return

        # Out of function range
        for i in md.disasm(instruction, address):
            if i.mnemonic == 'add' and i.op_str == 'byte ptr [eax], al':
#                print(self.raw_IAT)
                print('[-] EIP scope is not valid')
                self.uc.emu_stop()
                return

            if str(i.mnemonic) == 'call' and 'dword ptr [' in i.op_str:
                target = i.op_str.split('[')[1].split(']')[0]
                #print('here', i.op_str, target)
                if target not in self.raw_IAT and self.silent:
#                    print('[CHECKME]> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)
                    self.hook_syscall(i.op_str, 'call', i.address, i.bytes)
                else:
                    self.hook_syscall(i.op_str, 'call', i.address, i.bytes)


            elif str(i.mnemonic) == 'call':
                #print('[Debug]', i.mnemonic, i.op_str)
                self.hook_syscall(i.op_str, 'call', i.address, i.bytes)

            elif str(i.mnemonic) == 'jmp' and 'dword ptr [' in i.op_str:
                target = i.op_str.split('[')[1].split(']')[0]
                if target not in self.raw_IAT and not self.silent:
                    print('> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)
                else:
                    self.hook_syscall(i.op_str, 'jmp', i.address, i.bytes)
            else:
                if not self.silent:
                    print('> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)

    
    # Hook and trace syscalls
    def hook_syscall(self, instruction, mnemonic, addr, byte):
        is_ptr = False

        if '[' in instruction:
            is_ptr = True

        try:
            if instruction in regs:
                dest_addr = '0x%08x' % eval('self.uc.reg_read(UC_X86_REG_' + instruction.replace(' ','').upper() + ')')
            elif ('+' in instruction or '-' in instruction) and is_ptr:
                left_elem = instruction.split('[')[1].split(']')[0].split(' ')[0].replace(' ', '')
                operator = instruction.split('[')[1].split(']')[0].split(' ')[1].replace(' ', '')
                right_elem = instruction.split('[')[1].split(']')[0].split(' ')[2].replace(' ', '')
                if left_elem in regs:
                    left_value = hex(self.uc.reg_read(eval('UC_X86_REG_' + left_elem.upper())))
                    dest_addr_ptr = '0x%08x' % eval(left_value + operator + right_elem)
                    content = self.uc.mem_read(int(dest_addr_ptr, 16), 0x4)
                    dest_addr = '0x%08x' % struct.unpack('I', content)[0]
                else:
                    print('[-] Something went terribly wrong')
                    exit(1)
            else:
                dest_addr = '0x' + instruction.split('0x')[1].replace(']','')
        except:
            print('[-] Weird call at 0x%08X, investigate me ! "%s %s"' % (addr, mnemonic, instruction))
            return
        # Are we calling a function from the IAT in a weird way ?
        if str(dest_addr) in self.IAT_hook.values():
            # WORK_IN_PROGRESS_HERE
            target_iat_call = list(self.IAT_hook.keys())[list(self.IAT_hook.values()).index(dest_addr)] 
            for dll in self.IAT:
                for func_addr in self.IAT[dll]:
                    func_name = self.IAT[dll].get(func_addr)
                    if func_name == target_iat_call:
                        #print('[*] IAT call detected:', target_iat_call, func_addr)
                        dest_addr = func_addr
                        break
            #return

        # Is this targeting the IAT or a mapped function ?
        IAT_entry = list(self.raw_IAT.keys())
        if dest_addr not in IAT_entry:
            if not self.silent:
                print('> Tracing intruction ' + hex(addr), ':', mnemonic, self.shortname + '.' + str(instruction) )
                print('> Following function ' + self.shortname + '.' + str(instruction) + ':')
            if self.trace:
                self.calltrace.append(self.shortname + '.' + str(instruction))
            return

        api_name = self.raw_IAT[dest_addr]
        is_valid, description, args, args_count = self.extract_API_args(api_name)
        if not is_valid:
            if self.debug:
                print('[!] Unknown call destination, fix me dude')
            self.uc.emu_stop()

        if is_ptr:
            api_name = '&' + api_name 

        display_line = instruction.replace(dest_addr, api_name)
        if not self.silent:
            print('> Tracing intruction ' + hex(addr), ':', mnemonic, display_line)
#        print('> Tracing intruction ' + hex(addr), ': call', display_line + ' #' + description)
        if mnemonic == 'call':
            self.fake_syscall(addr, args_count, api_name, byte, 0x0) # Return 0 by default 
        elif mnemonic == 'jmp':
            self.fake_jmpcall(addr, args_count, api_name, byte, 0x0) # Return 0 by default 
        

    # Read <size> bytes from the stack address <start>
    def read_stack(self, start, size):
        print('=========== Stack Dump ==========')
        final_stack = self.uc.mem_read(start, size)
        stack_addr = start
        for x in range(0, size // 4):
            stack_addr += 4
            stack_content = final_stack[0:4]
            final_stack = final_stack[4:]
            stack_value = struct.unpack('I', stack_content)[0]
            print('0x%08x : 0x%08x' % (stack_addr, stack_value))


    # Fake syscall function
    def fake_syscall(self, addr, args_count, api, opcode, ret_value):
        api_name = api.replace('&', '')

        display = '> ' + hex(addr) + ': ' + api_name + '('
        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        val = self.uc.mem_read(current_esp, 4*args_count)

        loc_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        args = []
        for x in range(0, args_count):
            value = self.read_byte(loc_esp + (x*4))
            args.append(hex(value))

        # Test weather or not a special hook exist
        if api_name in dir(winsyscall):
            # This API need to be intercept with a special hardcoded hook
            function = getattr(winsyscall, api_name)
            ret_code, ret_args = function(self, args)
            if ret_args == 'EXIT':
                print(display + '0x0)')
                self.uc.emu_stop()
                return
            
            display += str(ret_args).replace('[', '').replace(']','').replace("'", '') + ') = '
            if ret_code != None:
                display += hex(ret_code)
            else:
                display += str(ret_code)
        else:
            clean_stack(self, args_count)
            ret_code = 0x0
            display += str(args).replace('[', '').replace(']', '').replace("'", '') + ') = '
            display += hex(ret_code)
        
        print(display)
       
        # Does the function return something ?
        if ret_code != None:
            # Fake return code to 0
            self.uc.reg_write(UC_X86_REG_EAX, ret_code)

        # Redirect EIP
        original_eip = self.uc.reg_read(UC_X86_REG_EIP)
        self.uc.reg_write(UC_X86_REG_EIP, original_eip + len(opcode))


    # Pop a value from the stack
    def popstack(self):
        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        val = self.uc.mem_read(current_esp, 4)
        stack_value = struct.unpack('I', val)[0]
        return stack_value


    # Decrement the stack value
    def decstack(self):
        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        self.uc.reg_write(UC_X86_REG_ESP, int(current_esp + 4))


    # Read a 4 byte value at a given address
    def read_byte(self, addr):
        val = self.uc.mem_read(addr, 4)
        formated_value = struct.unpack('I', val)[0]
        return formated_value


    # Fake jmp to syscall ptr
    def fake_jmpcall(self, addr, args_count, api, opcode, ret_value):
        display = '> ' + hex(addr) + ': ' + api.replace('&', '') + '('
        ret = self.popstack()
        self.decstack() 

        loc_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        loc_args = []
        for x in range(0, args_count):
            value = self.read_byte(loc_esp + (x*4))
            loc_args.append(hex(value))

        display += str(loc_args).replace('[', '').replace(']', '').replace("'", '') + ')'
        print(display)

        # Fake return code to 0
        self.uc.reg_write(UC_X86_REG_EAX, 0x0)
        
        # Redirect EIP
        self.uc.reg_write(UC_X86_REG_EIP, ret)


    # Print a list of used handles
    def read_handle(self):
        print('========= Opened Handles ========')
        for h in self.handle:
            handle_addr = h
            handle_value = self.handle[h][0]
            handle_type = self.handle[h][1]
            if handle_type == 'dummy':
                continue
            print('Address=' + str(handle_addr) + ' Type=' + str(handle_type) + ' Value=' + str(handle_value) )


    # Print a list of dynamically resolved functions
    def read_dynamic_imports(self):
        print('========= Dynamic Imports =======')
        for i in self.dynamics:
            print('Address=', i[0], ' Name=', i[1])


    # Print a dump of the current registers
    def read_full_regs(self):
        print('========== Regsitry Dump ========')
        print('EAX: 0x%08x | EBP: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EAX), self.uc.reg_read(UC_X86_REG_EBP)))
        print('EBX: 0x%08x | ESP: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EBX), self.uc.reg_read(UC_X86_REG_ESP)))
        print('ECX: 0x%08x | ESI: 0x%08x' % (self.uc.reg_read(UC_X86_REG_ECX), self.uc.reg_read(UC_X86_REG_ESI)))
        print('EDX: 0x%08x | EDI: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EDX), self.uc.reg_read(UC_X86_REG_EDI)))
        print('EIP: 0x%08x ' % self.uc.reg_read(UC_X86_REG_EIP))
     
    
    # Retreive the corresponding Windows API in our list
    def extract_API_args(self, api_name):
        with open(API_refs) as f:
            line = next((l for l in f if api_name == l.split(';')[0]), None)

        if line == None or line == '':
            # We're fucked mate
            return False, '', '', 0

        name = line.split(';')[0]
        description = line.split(';')[1].split(';')[0]
        args = line.split(';')[2]
        args_count = args.count(',') + 1
        if args_count == 1 and args.replace('\n', '').replace(' ','') == '':
            args_count = 0

        if args == '' or args == None:
            # We're double fucked maaaatee
#            print('[!] Cannot gather arguments count and type, fix me')
            return True, description, '', 0

        return True, description, args, args_count


    # Setup a fake IAT
    def generate_Import_Address_Table(self):
        self.IAT = {}
        self.raw_IAT = {}

        dll_count = 0
        functions_count = 0
        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            functions = {}
            dll_count += 1
            for imp in entry.imports:
                functions_count += 1
                #print(imp.name.decode())
                functions[hex(imp.address)] = imp.name.decode()
                self.raw_IAT[hex(imp.address)] = imp.name.decode()
            self.IAT[entry.dll.lower().decode()] = functions
        self.IAT['dynamic_import'] = {'0x00ff0000': 'placeholder_dynamic_import'}
        if self.debug:
            print('[DEBUG] ' + str(functions_count) + ' functions imported in the IAT from ' + str(dll_count) + ' DLL')

    # Setup a hook structure for the IAT
    def hook_Import_Address_Table(self):
        self.IAT_hook = {}
        cnt = 0
        for dll in self.IAT:
            if dll == 'dynamic_import':
                continue
            for entry_addr in self.IAT[dll]:
                entry = self.IAT[dll][entry_addr]
                #self.uc.mem_write(int(entry_addr, 16), bytes([cnt]))
                content = self.uc.mem_read(int(entry_addr, 16), 0x4)
                value = '0x' + struct.pack("<I", int(bytes(content).hex(), 16)).hex()
                self.IAT_hook[entry] = value
                cnt += 1
        #print(self.IAT_hook)
        if self.debug:
            print('[DEBUG] ' + str(cnt) + ' IAT entry where hooked')


    # Setup the process TIB structure
    def generate_Thread_Information_Block(self):
        self.TEB_base_addr = 0x200000
        self.process_ID = 0x1908
        self.thread_ID = 0x10C
        self.PEB_base_addr = self.TEB_base_addr + 0x1000
        
        TEB = b''
        TEB += struct.pack("<I", 0xffffffff)                            # FS:[0x00] Structure Exception Handler (SEH)
        TEB += struct.pack("<I", (self.stack_addr + self.stack_size))   # FS:[0x04] Stack Base
        TEB += struct.pack("<I", self.stack_addr)                       # FS:[0x08] Stack Limit
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x0C] Subsystem TIB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x10] Fiber Data
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x14] Arbitrary Data Slot
        TEB += struct.pack("<I", self.TEB_base_addr)                    # FS:[0x18] Linear Address of TEB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x1C] Environment Pointer
        TEB += struct.pack("<I", self.process_ID)                       # FS:[0x20] Process ID
        TEB += struct.pack("<I", self.thread_ID)                        # FS:[0x24] Current Thread ID
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x28] Active RPC Handle
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x2C] Linear Address of the thread-local storage array
        TEB += struct.pack("<I", self.PEB_base_addr)                    # FS:[0x30] Linear Address of the Process Environment Block (PEB)
       
        page_size=4096
        m = 0x5000 % page_size
        f = page_size - m
        aligned_size = 0x5000 + f

        # Map and write the TEB in memory
        self.uc.mem_map(self.TEB_base_addr, aligned_size)
        self.uc.mem_write(self.TEB_base_addr, TEB)


    def launch(self):
        # Get header most importants fields
        self.header_image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.header_size_of_image = self.pe.OPTIONAL_HEADER.SizeOfImage
        self.header_entrypoint = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.mapped_image = self.pe.get_memory_mapped_image(ImageBase=self.header_image_base)
        self.mapped_size = (len(self.mapped_image) + 0x1000) & ~0xFFF
        self.exit_addr = 0xfffff000

        # Get virtual size needed for PE mapping
        min_offset = sys.maxsize
        virtual_size = 0
        for section in self.pe.sections:
            min_offset = section.VirtualAddress
            virtual_size += min_offset
        virtual_size += min_offset
        m = virtual_size % 4096
        f = 4096 - m
        aligned_virtual_size = virtual_size + f
        
        # Map the binary in memory
        self.uc.mem_map(self.header_image_base, self.mapped_size)
        self.uc.mem_write(self.header_image_base, self.mapped_image)
        self.start_addr = self.header_entrypoint + self.header_image_base
        if self.debug:
            print('[DEBUG] Binary mapped in memory at 0x%08x' % self.header_image_base)

        # Initialize the stack
        self.stack_addr = 0x0
        self.stack_size = 0x100000
        self.uc.mem_map(self.stack_addr, self.stack_size)
        if self.debug:
            print('[DEBUG] Stack of 0x%x bytes starting at 0x%08x' % (self.stack_size, self.stack_addr))
        
        self.uc.reg_write(UC_X86_REG_ESP, self.stack_addr + self.stack_size - 0x400)
        self.uc.reg_write(UC_X86_REG_EBP, self.stack_addr + self.stack_size - 0x200)
        if self.debug:
            print('[DEBUG] Initial stack frame created between 0x%08x and 0x%08x' % (self.stack_size - 0x400, self.stack_size - 0x200))
       
        # Create a the TEB structure
        self.generate_Thread_Information_Block()
        if self.debug:
            print('[DEBUG] Thread Information Block initiated at 0x%08x' % self.TEB_base_addr)

        # Create a the PEB structure
        # TODO

        # Create a fake IAT
        self.generate_Import_Address_Table()
        
        # Place hooks on the IAT
        self.hook_Import_Address_Table()
        # Initiate the registers
        self.uc.reg_write(UC_X86_REG_EDI, self.start_addr)
        self.uc.reg_write(UC_X86_REG_ESI, self.start_addr)
        self.uc.reg_write(UC_X86_REG_EDX, self.start_addr)
        self.uc.reg_write(UC_X86_REG_ECX, self.start_addr)
        self.uc.reg_write(UC_X86_REG_EBX, self.PEB_base_addr) # EBP point to the PEB address
        self.uc.reg_write(UC_X86_REG_EAX, self.TEB_base_addr) # EAX point to the TIB address
        
        # Place a debug hook
        self.uc.hook_add(UC_HOOK_CODE, self.hook_code)

        # Start emulation
        print('[DEBUG] Starting the emulation of "%s.exe" from 0x%08x' % (self.drivename, self.start_addr))
        print()
        self.uc.emu_start(self.start_addr, self.start_addr + 100)
        print()
        
        # Display final program's state
        final_esp = self.uc.reg_read(UC_X86_REG_ESP)
        final_ebp = self.uc.reg_read(UC_X86_REG_EBP)

        if args.dynamics:
            self.read_dynamic_imports()
            print()

        if self.stack:
            self.read_stack(final_esp, final_ebp - final_esp)
            print()

        if self.registers:
            self.read_full_regs()
            print()

        if self.handle_list:
            self.read_handle()
            print()

        if self.trace:
            print('==== Call trace ====')
            print(' →  Entrypoint')
            for elem in self.calltrace:
                print(' →  ' + elem)

def main(args):
    emul = Environment(args)
    emul.launch()

parser = argparse.ArgumentParser(description='Windows Binary Emulator')
parser.add_argument('-p', '--path', required=True, help='path to the binary file to emulate')
parser.add_argument('-b', '--breakpoint', required=False, help='pause the execution at the given address')
parser.add_argument('--trace', required=False, action="store_true", help='display the call trace of the binary')
parser.add_argument('--dump', required=False, action="store_true", help='display a full dump of the program\'s state after the execution')
parser.add_argument('--stack', required=False, action="store_true", help='display a dump of the stack after the execution')
parser.add_argument('--registers', required=False, action="store_true", help='display a dump of the regsiters after the execution')
parser.add_argument('--debug', required=False, action="store_true", help='display debug messages')
parser.add_argument('--silent', required=False, action="store_true", help='only print out the system calls')
parser.add_argument('--handle', required=False, action="store_true", help='display the list of used handles')
parser.add_argument('--imports', required=False, action="store_true", help='UNIMPLEMENTED - display the static content of the import address table (IAT)')
parser.add_argument('--dynamics', required=False, action="store_true", help='display the list of dynamically resolved syscall')
parser.add_argument('--out', required=False, default='out.emu', help='UNIMPLEMENTED - save the emulation output to a file')
args = parser.parse_args()

main(args)


