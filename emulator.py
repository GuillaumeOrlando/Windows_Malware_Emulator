from unicorn import *
from unicorn.x86_const import *
from capstone import *
from importlib import import_module
from emulation.syscall import clean_stack
import argparse
import emulation.syscall as winsyscall
import pefile
import struct
import sys
import ast
import os

#TODO: Deal with SEH structure
#TODO: Randomize TEB base address
#TODO: Randomize process ID
#TODO: Randomize thread ID
#TODO: Process management
#TODO: Thread management
#TODO: Fake FileSystem
#TODO: Fake running process

API_refs = 'winapi_9k.csv'
regs = ['eax', 'ebx', 'ecx', 'edx', 'esp', 'ebp', 'edi', 'esi']

md = Cs(CS_ARCH_X86, CS_MODE_32)
full_content = ''


class colors:
    ENDC =    '\033[0m'
    GRAY = '\033[93m'
    CHANGED = '\033[91m'
    EAX = '\033[0m'
    EBX = '\033[0m'
    ECX = '\033[0m'
    EDX = '\033[0m'
    EBP = '\033[0m'
    ESP = '\033[0m'
    ESI = '\033[0m'
    EDI = '\033[0m'
    

class Environment:

    def __init__(self, args):
        # Argument validation
        self.breakpoint = args.breakpoint
        self.trace = args.trace
        self.dump = args.dump
        self.silent = args.silent
        self.out = args.out
        self.stack = args.stack
        self.strings = args.strings
        self.registers = args.registers
        self.debug = args.debug
        self.handle_list = args.handle
        self.show_extract = args.extract
        self.imports = args.imports
        self.dynamics = []
        self.calltrace = []
        self.buffer = args.buffer
        self.alloc_buffer = []
        if self.stack and self.registers:
            self.dump = True
        if self.dump:
            self.registers = True
            self.stack = True

        path = args.path
        self.shortname = path.split('/')[-1].split('.')[0].lower()
        self.drivename = 'C:\\Users\\EllenRipley\\Desktop\\' + self.shortname
        self.username = 'EllenRipley'
        self.computername = 'Nostromo'
        self.computer_mac = '0F-0C-95-86-20-29'
        self.computer_ip = '192.168.0.12'
        self.path = path
        self.chunks = []
        self.virtual_memory = []
        self.resources = {}
        self.extracts = {}
        self.extract_strings = []
        self.threads = []
        self.thread_ret = None
        self.thread_trace = []
        self.thread_max_replay = 255
        self.max_loop = 255
        self.current_loop_counter = 0
        self.previous_loop = []
        self.current_loop = []
        self.execution_mode = 'default'
        self.uc = Uc(UC_ARCH_X86, UC_MODE_32)
        self.handle = {'0xaa': ['placeholder_dynamic_handle', 'dummy']}
        self.last_eax = 0
        self.last_ebx = 0
        self.last_ecx = 0
        self.last_edx = 0
        self.last_ebp = 0
        self.last_esp = 0
        self.last_esi = 0
        self.last_edi = 0
        try:
            self.pe = pefile.PE(path)
        except OSError as e:
            print(e)
            exit -1
        except pefile.PEFormatError as e:
            print(f'Malformated or invalid PE file: {e.value}')
            exit -1
 
    # Update the color of the registers while in 'debugger' mode for quick identification
    def update_color(self, reg):
        if reg == 'eax':
            cur_eax = self.uc.reg_read(UC_X86_REG_EAX)
            if self.last_eax != cur_eax:
                colors.EAX = colors.CHANGED
            else:
                colors.EAX = colors.ENDC
            return cur_eax
        if reg == 'ebx':
            cur_ebx = self.uc.reg_read(UC_X86_REG_EBX)
            if self.last_ebx != cur_ebx:
                colors.EBX = colors.CHANGED
            else:
                colors.EBX = colors.ENDC
            return cur_ebx
        if reg == 'ecx':
            cur_ecx = self.uc.reg_read(UC_X86_REG_ECX)
            if self.last_ecx != cur_ecx:
                colors.ECX = colors.CHANGED
            else:
                colors.ECX = colors.ENDC
            return cur_ecx
        if reg == 'edx':
            cur_edx = self.uc.reg_read(UC_X86_REG_EDX)
            if self.last_edx != cur_edx:
                colors.EDX = colors.CHANGED
            else:
                colors.EDX = colors.ENDC
            return cur_edx
        if reg == 'ebp':
            cur_ebp = self.uc.reg_read(UC_X86_REG_EBP)
            if self.last_ebp != cur_ebp:
                colors.EBP = colors.CHANGED
            else:
                colors.EBP = colors.ENDC
            return cur_ebp
        if reg == 'esp':
            cur_esp = self.uc.reg_read(UC_X86_REG_ESP)
            if self.last_esp != cur_esp:
                colors.ESP = colors.CHANGED
            else:
                colors.ESP = colors.ENDC
            return cur_esp
        if reg == 'esi':
            cur_esi = self.uc.reg_read(UC_X86_REG_ESI)
            if self.last_esi != cur_esi:
                colors.ESI = colors.CHANGED
            else:
                colors.ESI = colors.ENDC
            return cur_esi
        if reg == 'edi':
            cur_edi = self.uc.reg_read(UC_X86_REG_EDI)
            if self.last_edi != cur_edi:
                colors.EDI = colors.CHANGED
            else:
                colors.EDI = colors.ENDC
            return cur_edi


    # Log every instruction emulated
    def hook_code(self, a, address, size, user_data):
        instruction = self.uc.mem_read(address, size)

        # Manual Breakpoint
        if self.breakpoint:
            if hex(address) == self.breakpoint:
                final_esp = self.uc.reg_read(UC_X86_REG_ESP)
                final_ebp = self.uc.reg_read(UC_X86_REG_EBP)
                final_stack = self.uc.mem_read(final_esp, 68)
                stack_content = [final_stack[i:i+4] for i in range(0, len(final_stack), 4)]
                    
                # Highlight changes
                self.last_eax = self.update_color('eax')
                self.last_ebx = self.update_color('ebx')
                self.last_ecx = self.update_color('ecx')
                self.last_edx = self.update_color('edx')
                self.last_esp = self.update_color('esp')
                self.last_ebp = self.update_color('ebp')
                self.last_esi = self.update_color('esi')
                self.last_edi = self.update_color('edi')

                print('\n Registers:\t\t\t\t\tStack:')
                print(f' EAX: {colors.EAX}0x%08x{colors.ENDC} | EBP: {colors.EBP}0x%08x{colors.ENDC}\t\t0x%08x: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EAX), self.uc.reg_read(UC_X86_REG_EBP), final_esp+0, struct.unpack('I', stack_content[0])[0]))
                print(f' EBX: {colors.EBX}0x%08x{colors.ENDC} | ESP: {colors.ESP}0x%08x{colors.ENDC}\t\t0x%08x: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EBX), self.uc.reg_read(UC_X86_REG_ESP), final_esp+4, struct.unpack('I', stack_content[1])[0]))
                print(f' ECX: {colors.ECX}0x%08x{colors.ENDC} | ESI: {colors.ESI}0x%08x{colors.ENDC}\t\t0x%08x: 0x%08x' % (self.uc.reg_read(UC_X86_REG_ECX), self.uc.reg_read(UC_X86_REG_ESI), final_esp+8, struct.unpack('I', stack_content[2])[0]))
                print(f' EDX: {colors.EDX}0x%08x{colors.ENDC} | EDI: {colors.EDI}0x%08x{colors.ENDC}\t\t0x%08x: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EDX), self.uc.reg_read(UC_X86_REG_EDI), final_esp+12, struct.unpack('I', stack_content[3])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+16, struct.unpack('I', stack_content[4])[0]))
                print(f' EIP: 0x%08x  (Breakpoint hit)\t\t0x%08x: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EIP), final_esp+20, struct.unpack('I', stack_content[5])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+24, struct.unpack('I', stack_content[6])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+28, struct.unpack('I', stack_content[7])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+32, struct.unpack('I', stack_content[8])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+32, struct.unpack('I', stack_content[9])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+34, struct.unpack('I', stack_content[10])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+38, struct.unpack('I', stack_content[11])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+42, struct.unpack('I', stack_content[12])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+46, struct.unpack('I', stack_content[13])[0]))
                print(f'\t\t\t\t\t\t0x%08x: 0x%08x' % (final_esp+50, struct.unpack('I', stack_content[14])[0]))

                self.calltrace.append('breakpoint')
                bchoice = input('\n [s] Single step (default) / [c] Continue / [e] Exit  > ')
                print('--------------------------------------------------------------\n')
                if bchoice == 'e' or bchoice == 'exit':
                    self.uc.emu_stop()
                    return
                elif bchoice == 's' or bchoice == 'step' or bchoice == '':
                   self.breakpoint = hex(address + size)
                elif bchoice == 'c' or bchoice == 'continue':
                    print(' Execution resumed')
                else:
                    print('[-] Invalid choice')
                    self.uc.emu_stop()
                    return

        # Out of function range
        for i in md.disasm(instruction, address):
            #if 'int' in i.mnemonic:
                #original_eip = self.uc.reg_read(UC_X86_REG_EIP)
                #self.uc.reg_write(UC_X86_REG_EIP, original_eip + len(i.bytes))
                #return

            if i.mnemonic == 'add' and i.op_str == 'byte ptr [eax], al':
                print('[!] End of the main emulation thread')
                self.uc.emu_stop()
                return

            # Bypass traps to debuger
            #if str(i.mnemonic) == 'int3':
            #    if not self.silent:
            #        print('> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)
            #    original_eip = self.uc.reg_read(UC_X86_REG_EIP)
            #    self.uc.reg_write(UC_X86_REG_EIP, original_eip + len(i.bytes))

            if str(i.mnemonic) == 'call' and 'dword ptr [' in i.op_str:
                target = i.op_str.split('[')[1].split(']')[0]
                if target not in self.raw_IAT and self.silent:
#                   print('[CHECKME]> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)
                    self.hook_syscall(i.op_str, 'call', i.address, i.bytes)
                else:
                    self.hook_syscall(i.op_str, 'call', i.address, i.bytes)

            elif str(i.mnemonic) == 'call':
                #print('[Debug]', i.mnemonic, i.op_str)
                self.hook_syscall(i.op_str, 'call', i.address, i.bytes)

            elif str(i.mnemonic) == 'jmp' and 'dword ptr [' in i.op_str:
                target = i.op_str.split('[')[1].split(']')[0]
                if i.op_str in regs:
                    dest_addr = '0x%08x' % eval('self.uc.reg_read(UC_X86_REG_' + i.op_str.replace(' ','').upper() + ')')
                elif ('+' in i.op_str or '-' in i.op_str or '*' in i.op_str):
                    left_elem = i.op_str.split('[')[1].split(']')[0].split(' ')[0].replace(' ', '')
                    operator = i.op_str.split('[')[1].split(']')[0].split(' ')[1].replace(' ', '')
                    right_elem = i.op_str.split('[')[1].split(']')[0].split(' ')[2].replace(' ', '')
                    # call/jmp [eax+4]
                    if left_elem in regs:
                        left_value = hex(self.uc.reg_read(eval('UC_X86_REG_' + left_elem.upper())))
                        dest_addr_ptr = '0x%08x' % eval(left_value + operator + right_elem)
                        content = self.uc.mem_read(int(dest_addr_ptr, 16), 0x4)
                        target = '0x%08x' % struct.unpack('I', content)[0]
                    # call/jmp [eax*4 + 10]
                    elif '+' in left_elem or '-' in left_elem or '*' in left_elem:
                        lleft_elem = left_elem.split('*')[0].split('-')[0].split('+')[0]
                        lleft_value = hex(self.uc.reg_read(eval('UC_X86_REG_' + lleft_elem.upper())))
                        lleft_op = left_elem.replace(lleft_elem, lleft_value)
                        dest_addr_ptr = '0x%08x' % eval(lleft_op + operator + right_elem)
                        content = self.uc.mem_read(int(dest_addr_ptr, 16), 0x4)
                        target = '0x%06x' % struct.unpack('I', content)[0]
                    else:
                        print('[-] Something went terribly wrong')
                        exit(1)
                else:
                    target = i.op_str.split('[')[1].split(']')[0] 
                if target not in self.raw_IAT:
                    #self.hook_syscall(i.op_str, 'jmp', i.address, i.bytes)
                    if not self.silent:
                        print(f'> Tracing intruction {hex(i.address)} : {i.mnemonic} {i.op_str}')
                    self.hook_syscall(i.op_str, 'jmp', i.address, i.bytes)
                else:
                    self.hook_syscall(i.op_str, 'jmp', i.address, i.bytes)
            else:
                if not self.silent:
                    print(f'> Tracing intruction {hex(i.address)} : {i.mnemonic} {i.op_str}')

    
    # Hook and trace syscalls
    def hook_syscall(self, instruction, mnemonic, addr, byte):
        if self.execution_mode == 'default':
            self.thread_trace.append(addr)
            dup_api = {i:self.thread_trace.count(i) for i in self.thread_trace}
            for elem in dup_api:
                rep = dup_api[elem]
                if rep >= self.thread_max_replay:
                    self.uc.emu_stop()
                    if self.debug:
                        print('[!] Primary thread stoped due to it\'s repetition (infinite loop)')
                    return
        
        if self.execution_mode == 'thread':
            self.thread_trace.append(addr)
            dup_api = {i:self.thread_trace.count(i) for i in self.thread_trace}
            for elem in dup_api:
                rep = dup_api[elem]
                if rep >= self.thread_max_replay:
                    self.uc.emu_stop()
                    if self.debug:
                        print('[!] Thread stoped due to it\'s repetition (infinite loop)')
                    return

        is_ptr = False

        if '[' in instruction:
            is_ptr = True

        try:
            if instruction in regs:
                dest_addr = '0x%08x' % eval('self.uc.reg_read(UC_X86_REG_' + instruction.replace(' ','').upper() + ')')
            elif ('+' in instruction or '-' in instruction) and is_ptr:
                left_elem = instruction.split('[')[1].split(']')[0].split(' ')[0].replace(' ', '')
                operator = instruction.split('[')[1].split(']')[0].split(' ')[1].replace(' ', '')
                right_elem = instruction.split('[')[1].split(']')[0].split(' ')[2].replace(' ', '')
                # call/jmp [eax+4]
                if left_elem in regs:
                    left_value = hex(self.uc.reg_read(eval('UC_X86_REG_' + left_elem.upper())))
                    dest_addr_ptr = '0x%08x' % eval(left_value + operator + right_elem)
                    content = self.uc.mem_read(int(dest_addr_ptr, 16), 0x4)
                    dest_addr = '0x%08x' % struct.unpack('I', content)[0]
                # call/jmp [eax*4 + 10]
                elif '+' in left_elem or '-' in left_elem or '*' in left_elem:
                    lleft_elem = left_elem.split('*')[0].split('-')[0].split('+')[0]
                    lleft_value = hex(self.uc.reg_read(eval('UC_X86_REG_' + lleft_elem.upper())))
                    lleft_op = left_elem.replace(lleft_elem, lleft_value)
                    dest_addr_ptr = '0x%08x' % eval(lleft_op + operator + right_elem)
                    content = self.uc.mem_read(int(dest_addr_ptr, 16), 0x4)
                    dest_addr = '0x%08x' % struct.unpack('I', content)[0]
                else:
                    print('[-] Something went terribly wrong')
                    exit(1)
            else:
                dest_addr = '0x' + instruction.split('0x')[1].replace(']','')
        except:
            print('[-] Weird call at 0x%08X, investigate me ! "%s %s"' % (addr, mnemonic, instruction))
            return
        # Are we calling a function from the IAT in a weird way ?
        #print(self.IAT)
        if str(dest_addr) in self.IAT_hook.values():
            target_iat_call = list(self.IAT_hook.keys())[list(self.IAT_hook.values()).index(dest_addr)] 
            for dll in self.IAT:
                for func_addr in self.IAT[dll]:
                    func_name = self.IAT[dll].get(func_addr)
                    if func_name == target_iat_call:
                        #print('[*] IAT call detected:', target_iat_call, func_addr)
                        dest_addr = func_addr
                        break
            #return

        # Is this targeting the IAT or a mapped function ?
        api_name_tmp = None
        IAT_entry = list(self.raw_IAT.keys())
        if dest_addr not in IAT_entry:
            if is_ptr:
                raw_ptr = self.uc.mem_read(int(dest_addr, 16), 0x4)
                ptr = '0x%08x' % struct.unpack('<I', raw_ptr)[0]
                if ptr in self.IAT_hook.values():
                    try:
                        api_name_tmp = [k for k,v in self.IAT_hook.items() if v == ptr][0]
                    except:
                        api_name_tmp = None
            else: 
                if not self.silent:
                    print(f'> Tracing intruction {hex(addr)} : {mnemonic} {self.shortname + "." + str(instruction)}' )
                    print('> Following function ' + self.shortname + '.' + str(instruction) + ':')
                    self.calltrace.append(self.shortname + '.' + str(instruction))
                return

        if api_name_tmp == None:
            try:
                api_name = self.raw_IAT[dest_addr]
            except:
                return
        else:
            api_name = api_name_tmp
        is_valid, description, args, args_count = self.extract_API_args(api_name)
        if not is_valid:
            if self.debug:
                print('[!] Unknown call destination, fix me dude')
            self.uc.emu_stop()

        if is_ptr:
            api_name = '&' + api_name 

        display_line = instruction.replace(dest_addr, api_name)
        if not self.silent:
            print(f'> Tracing intruction {hex(addr)} : {mnemonic} {display_line}')
#        print('> Tracing intruction ' + hex(addr), ': call', display_line + ' #' + description)
        if mnemonic == 'call':
            self.fake_syscall(addr, args_count, api_name, byte, 0x0) # Return 0 by default 
        elif mnemonic == 'jmp':
            self.fake_jmpcall(addr, args_count, api_name, byte, 0x0) 

    # Read <size> bytes from the stack address <start>
    def read_stack(self, start, size):
        print('=========== Stack Dump ==========')
        size = 64
        final_stack = self.uc.mem_read(start, size)
        stack_addr = start
        for x in range(0, size // 4):
            stack_addr += 4
            stack_content = final_stack[0:4]
            final_stack = final_stack[4:]
            stack_value = struct.unpack('I', stack_content)[0]
            print('0x%08x : 0x%08x' % (stack_addr, stack_value))


    # Fake syscall function
    def fake_syscall(self, addr, args_count, api, opcode, ret_value):
        api_name = api.replace('&', '')

        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        val = self.uc.mem_read(current_esp, 4*args_count)

        loc_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        args = []
        for x in range(0, args_count):
            value = self.read_byte(loc_esp + (x*4))
            args.append(hex(value))

        convention = self.get_calling_convention(addr, opcode, args_count, 'syscall')
        display = '> ' + hex(addr) + ': (' + convention + ') ' + api_name + '('
        # Test weather or not a special hook exist
        if api_name in dir(winsyscall):
            # This API need to be intercept with a special hardcoded hook
            function = getattr(winsyscall, api_name)
            ret_code, ret_args = function(self, args)
            
            if convention == '_stdcall':
                clean_stack(self, args_count)
   
            if ret_code == 'THREAD':
                taddr = int(self.threads[-1])
                ret_code = 0x1
                for elem in self.handle:
                    hval = self.handle[elem][0]
                    if hval == taddr:
                        ret_code = int(elem, 16)
                        break
                if self.debug:
                    print('[!] Spawning a new thread at ' + hex(self.threads[-1]))
            
            if ret_args == 'EXIT':
                print(display + '0x0)')
                self.uc.emu_stop()
                return
            
            display += str(ret_args).replace('[', '').replace(']','').replace("'", '') + ') = '
            if ret_code != None:
                display += hex(ret_code)
            else:
                display += str(ret_code)
        else:
            if convention == '_stdcall':
                clean_stack(self, args_count)

            ret_code = 0x0
            display += str(args).replace('[', '').replace(']', '').replace("'", '') + ') = '
            display += hex(ret_code)
            # Avoid dead end / infinite loop
            if len(self.current_loop) < self.max_loop:
                self.current_loop.append(addr)
            elif len(self.current_loop) == self.max_loop:
                if self.previous_loop.sort() == self.current_loop.sort():
                    if self.current_loop_counter == self.max_loop:
                        print('[!] Inifinite loop detected, stoping the emulation')
                        self.uc.emu_stop()
                        return
                    self.current_loop =  []
                    self.current_loop_counter += 1
                else:
                    self.previous_loop = self.current_loop
       
        if display.count('"') == 2:
            addr = display.split('> ')[1].split(':')[0]
            ex_string = display.split('"')[1].split('"')[0]
            self.extract_strings.append(ex_string + ':' + str(addr))

        #display = display.replace('="', "=\"{colors.CHANGED}").replace('",', "{colors.ENDC}\",")
        print(f"{display}")

        # Does the function return something ?
        if ret_code != None:
            # Fake return code to 0
            self.uc.reg_write(UC_X86_REG_EAX, ret_code)

        # Redirect EIP
        original_eip = self.uc.reg_read(UC_X86_REG_EIP)
        self.uc.reg_write(UC_X86_REG_EIP, original_eip + len(opcode))


    # Pop a value from the stack
    def popstack(self):
        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        val = self.uc.mem_read(current_esp, 4)
        stack_value = struct.unpack('I', val)[0]
        return stack_value


    # Decrement the stack value
    def decstack(self):
        current_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        self.uc.reg_write(UC_X86_REG_ESP, int(current_esp + 4))


    # Read a 4 byte value at a given address
    def read_byte(self, addr):
        val = self.uc.mem_read(addr, 4)
        formated_value = struct.unpack('I', val)[0]
        return formated_value


    # Determine the calling convention in order to emulate the callee cleaning the stack, or leting the program do it on it's own
    def get_calling_convention(self, address, opcodes, args_cnt, call_type):
        if call_type == 'syscall':
            n_instruction = self.uc.mem_read(address + len(opcodes), 30)
        else:
            n_instruction = self.uc.mem_read(address, 30)
        ins_cnt = 0
        for i in md.disasm(n_instruction, address):
#            break
            if (i.mnemonic == 'add' and i.op_str == 'esp, ' + hex(args_cnt*4)):
                c = '_cdecl  '
                break
            elif (i.mnemonic == 'add' and i.op_str == 'esp, ' + str(int(hex(args_cnt*4), 16))):
                c = '_cdecl  '
                break
            elif (i.mnemonic == 'add' and 'esp, ' in i.op_str and args_cnt == 0):
                c = '_cdecl  '
                break
            elif (i.mnemonic == 'pop' and ins_cnt == 0 and call_type != 'syscall'):
                c = '_cdecl  '
                break
            else:
                c = '_stdcall'
            ins_cnt += 1
        return c


    # Fake jmp to syscall ptr
    def fake_jmpcall(self, addr, args_count, api, opcode, ret_value):
        ret = self.popstack()
        #print(hex(ret))
        self.decstack() 
        
        loc_esp = self.uc.reg_read(UC_X86_REG_ESP) 
        loc_args = []
        for x in range(0, args_count):
            value = self.read_byte(loc_esp + (x*4))
            loc_args.append(hex(value))

#        display += str(loc_args).replace('[', '').replace(']', '').replace("'", '') + ''
        args = loc_args
        api_name = api.replace('&', '')
        convention = self.get_calling_convention(ret, opcode, args_count, 'jmpcall')
        display = '> ' + hex(addr) + ': (' + convention + ') ' + api.replace('&', '') + '('
        if api_name in dir(winsyscall):
            # This API need to be intercept with a special hardcoded hook
            function = getattr(winsyscall, api_name)
            ret_code, ret_args = function(self, args)

            # check if malloc(à is indeed a stdcall function
            if convention == '_stdcall':
                clean_stack(self, len(args))

            if ret_code == 'THREAD':
                taddr = int(self.threads[-1])
                ret_code = 0x1
                for elem in self.handle:
                    hval = self.handle[elem][0]
                    if hval == taddr:
                        ret_code = int(elem, 16)
                        break
                if self.debug:
                    print('[!] Spawning a new thread at ' + hex(self.threads[-1]))
            
            if ret_args == 'EXIT':
                print(display + '0x0)')
                self.uc.emu_stop()
                return
            
            display += str(ret_args).replace('[', '').replace(']','').replace("'", '') + ') = '
            if ret_code != None:
                display += hex(ret_code)
            else:
                display += str(ret_code)
        else:
            if convention == '_stdcall':
                clean_stack(self, len(args))
            
            ret_code = 0x0
            display += str(args).replace('[', '').replace(']', '').replace("'", '') + ') = '
            display += hex(ret_code)
            # Avoid dead end / infinite loop
            if len(self.current_loop) < self.max_loop:
                self.current_loop.append(addr)
            elif len(self.current_loop) == self.max_loop:
                if self.previous_loop.sort() == self.current_loop.sort():
                    if self.current_loop_counter == self.max_loop:
                        print('[!] Inifinite loop detected, stoping the emulation')
                        self.uc.emu_stop()
                        return
                    self.current_loop =  []
                    self.current_loop_counter += 1
                else:
                    self.previous_loop = self.current_loop
        
        if display.count('"') == 2:
            addr = display.split('> ')[1].split(':')[0]
            ex_string = display.split('"')[1].split('"')[0]
            self.extract_strings.append(ex_string + ':' + str(addr))

        print(display)

        # Does the function return something ?
        if ret_code != None:
            # Fake return code to 0
            self.uc.reg_write(UC_X86_REG_EAX, ret_code)
        else:
            # Fake return code to 0
            self.uc.reg_write(UC_X86_REG_EAX, 0x0)
        
        # Redirect EIP
        self.uc.reg_write(UC_X86_REG_EIP, ret)


    # Print a list of used handles
    def read_handle(self):
        print('========= Opened Handles ========')
        for h in self.handle:
            handle_addr = h
            handle_value = self.handle[h][0]
            handle_type = self.handle[h][1]
            if handle_type == 'dummy':
                continue
            if len(str(handle_value)) > 50:
                handle_value = str(handle_value)[:25] + '[...]' + str(handle_value)[-9:]
            print('Address=' + str(handle_addr) + ' Type=' + str(handle_type) + ' Value=' + str(handle_value) )

    #SHow buffer content
    def display_buffer(self):
        print('======= Allocated Buffer =======')
        for elem in self.alloc_buffer:
            addr = elem['address']
            size = elem['size']
            atype = elem['type']
            try:
                content = self.uc.mem_read(addr, size)
            except:
                content = 'Unable to access this buffer'
            if size < 400:
                print('Address=' + hex(addr) + ', Size=' + hex(size) + ', Content=' + str(content))
            else:
                #print('Address=' + hex(addr) + ', Size=' + hex(size) + ', Content=[...] Redacted')
                print('Address=' + hex(addr) + ', Size=' + hex(size) + ', Contnent='+ str(content))
            if 'MZ' in str(content):
                print('ok')

    # Show dynamically extracted strings
    def display_strings(self):
        print('======= Extracted Strings =======')
        for ex_str in self.extract_strings:
            if ex_str.split(':')[0] != '':
                addr = ex_str.split(':')[-1]
                print('Address=' + str(addr) + ' String=' + str(ex_str.replace(':' + addr, '')))

    # Show and extract potentials payloads
    def display_extracts(self):
        # Search Binary in allocated memory regions
        for elem in self.alloc_buffer:
            addr = elem['address']
            size = elem['size']
            atype = elem['type']
            content = self.uc.mem_read(addr, size)
            detail = ''
            if 'MZ' in str(content):
                self.extracts['hmemory_' + hex(addr) + '_' + str(atype)] = content

        #for vmem in self.virtual_memory:
        #    content = self.uc.mem_read(vmem.data_address, vmem.data_size)
        #    if content[:2] == b'MZ':
        #        self.extracts['hmemory_' + hex(vmem.data_address)] = content

        print('======= Extracted Payloads =======')
        if len(self.extracts) == 0:
            print('Nothing found')
            return

        dirname = './' + self.shortname + '_emu'
        if not os.path.exists(dirname):
            os.makedirs(dirname)

        counter = 0
        for entry in self.extracts:
            name = entry[1:]
            options = ''
            data = self.extracts[entry]
            if len(str(data)) > 50:
                sdata = str(data)[:25] + '[...]' + str(data)[-9:]
            else:
                sdata = data
            if data[:2] == b'MZ' or data[:2] == 'MZ':
                options = ' (PE payload detected)'
            fname = name.split('\\')[-1]
            if fname == '':
                fname = 'generic_extract_' + str(counter) + '.bin'
            f = open(dirname + '/' + fname, 'wb')
            f.write(data)
            f.close()
            print('Name="' + dirname + '/' + fname + '" Content="' + sdata + '"' + options + ', ' + detail)


    # Print a list of dynamically resolved functions
    def read_dynamic_imports(self):
        print('========= Dynamic Imports =======')
        if len(self.dynamics) == 0x0:
            print('No dynamic imports where detected during the emulation')
        for i in self.dynamics:
            print('Address=', i[0], ' Name=', i[1])


    # Print a dump of the current registers
    def read_full_regs(self):
        print('=== Registers Dump ===')
        print('EAX: 0x%08x | EBP: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EAX), self.uc.reg_read(UC_X86_REG_EBP)))
        print('EBX: 0x%08x | ESP: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EBX), self.uc.reg_read(UC_X86_REG_ESP)))
        print('ECX: 0x%08x | ESI: 0x%08x' % (self.uc.reg_read(UC_X86_REG_ECX), self.uc.reg_read(UC_X86_REG_ESI)))
        print('EDX: 0x%08x | EDI: 0x%08x' % (self.uc.reg_read(UC_X86_REG_EDX), self.uc.reg_read(UC_X86_REG_EDI)))
        print('EIP: 0x%08x ' % self.uc.reg_read(UC_X86_REG_EIP))
     
    
    # Retreive the corresponding Windows API in our list
    def extract_API_args(self, api_name):
        with open(API_refs) as f:
            line = next((l for l in f if api_name == l.split(';')[0]), None)

        if line == None or line == '':
            # We're fucked mate
            return False, '', '', 0

        name = line.split(';')[0]
        description = line.split(';')[1].split(';')[0]
        args = line.split(';')[2]
        args_count = args.count(',') + 1
        if args_count == 1 and args.replace('\n', '').replace(' ','') == '':
            args_count = 0

        if args == '' or args == None:
            # We're double fucked maaaatee
#            print('[!] Cannot gather arguments count and type, fix me')
            return True, description, '', 0

        return True, description, args, args_count


    # Setup a fake IAT
    def generate_Import_Address_Table(self):
        self.IAT = {}
        self.raw_IAT = {}

        dll_count = 0
        functions_count = 0
        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            functions = {}
            dll_count += 1
            for imp in entry.imports:
                #print(imp.name.decode())
                #print(imp.ordinal, imp.name, entry.dll)
                try:
                    functions[hex(imp.address)] = imp.name.decode()
                    self.raw_IAT[hex(imp.address)] = imp.name.decode()
                    functions_count += 1
                except:
                    continue
            self.IAT[entry.dll.lower().decode()] = functions
        self.IAT['dynamic_import'] = {'0x00ff0000': 'placeholder_dynamic_import'}
        if self.debug:
            print('[DEBUG] ' + str(functions_count) + ' functions imported in the IAT from ' + str(dll_count) + ' DLL')

    # Setup a hook structure for the IAT
    def hook_Import_Address_Table(self):
        self.IAT_hook = {}
        cnt = 0
        for dll in self.IAT:
            if dll == 'dynamic_import':
                continue
            for entry_addr in self.IAT[dll]:
                entry = self.IAT[dll][entry_addr]
                #self.uc.mem_write(int(entry_addr, 16), bytes([cnt]))
                content = self.uc.mem_read(int(entry_addr, 16), 0x4)
                value = '0x' + struct.pack("<I", int(bytes(content).hex(), 16)).hex()
                self.IAT_hook[entry] = value
                cnt += 1
        #print(self.IAT_hook)
        if self.debug:
            print('[DEBUG] ' + str(cnt) + ' IAT entry where hooked')


    # Setup the process TIB structure
    def generate_Thread_Information_Block(self):
        self.TEB_base_addr = 0x200000
        self.process_ID = 0x1908
        self.thread_ID = 0x10C
        self.PEB_base_addr = self.TEB_base_addr + 0x1000
        
        TEB = b''
        TEB += struct.pack("<I", 0xffffffff)                            # FS:[0x00] Structure Exception Handler (SEH)
        TEB += struct.pack("<I", (self.stack_addr + self.stack_size))   # FS:[0x04] Stack Base
        TEB += struct.pack("<I", self.stack_addr)                       # FS:[0x08] Stack Limit
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x0C] Subsystem TIB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x10] Fiber Data
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x14] Arbitrary Data Slot
        TEB += struct.pack("<I", self.TEB_base_addr)                    # FS:[0x18] Linear Address of TEB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x1C] Environment Pointer
        TEB += struct.pack("<I", self.process_ID)                       # FS:[0x20] Process ID
        TEB += struct.pack("<I", self.thread_ID)                        # FS:[0x24] Current Thread ID
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x28] Active RPC Handle
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x2C] Linear Address of the thread-local storage array
        TEB += struct.pack("<I", self.PEB_base_addr)                    # FS:[0x30] Linear Address of the Process Environment Block (PEB)
       
        page_size=4096
        m = 0x5000 % page_size
        f = page_size - m
        aligned_size = 0x5000 + f

        # Map and write the TEB in memory
        self.uc.mem_map(self.TEB_base_addr, aligned_size)
        self.uc.mem_write(self.TEB_base_addr, TEB)


    def launch(self):
        # Get header most importants fields
        self.header_image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.header_size_of_image = self.pe.OPTIONAL_HEADER.SizeOfImage
        self.header_entrypoint = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.mapped_image = self.pe.get_memory_mapped_image(ImageBase=self.header_image_base)
        self.mapped_size = (len(self.mapped_image) + 0x3000) & ~0xFFF
        self.exit_addr = 0xfffff000

        # Redirect to file
        if self.out != None:
            sys.stdout = open(self.out, "w")

        # Get virtual size needed for PE mapping
        min_offset = sys.maxsize
        virtual_size = 0
        for section in self.pe.sections:
            min_offset = section.VirtualAddress
            virtual_size += min_offset
        virtual_size += min_offset
        m = virtual_size % 4096
        f = 4096 - m
        aligned_virtual_size = virtual_size + f
        
        # Map the binary in memory
        self.uc.mem_map(self.header_image_base, self.mapped_size)
        self.uc.mem_write(self.header_image_base, self.mapped_image)
        self.start_addr = self.header_entrypoint + self.header_image_base
        if self.debug:
            print('[DEBUG] Binary mapped in memory at 0x%08x (%d bytes)' % (self.header_image_base, self.mapped_size))

        # Initialize the stack
        self.stack_addr = 0x0
        self.stack_size = 0x200000
        self.uc.mem_map(self.stack_addr, self.stack_size)
        if self.debug:
            print('[DEBUG] Stack of 0x%x bytes starting at 0x%08x' % (self.stack_size, self.stack_addr))
        
        self.uc.reg_write(UC_X86_REG_ESP, self.stack_addr + self.stack_size - 0x700)
        self.uc.reg_write(UC_X86_REG_EBP, self.stack_addr + self.stack_size - 0x100)
        if self.debug:
            print('[DEBUG] Initial stack frame created between 0x%08x and 0x%08x' % (self.stack_size - 0x700, self.stack_size - 0x100))
       
        # Create a the TEB structure
        self.generate_Thread_Information_Block()
        if self.debug:
            print('[DEBUG] Thread Information Block initiated at 0x%08x' % self.TEB_base_addr)

        # Create a the PEB structure
        # TODO

        # Create a fake IAT
        self.generate_Import_Address_Table()
        
        # Place hooks on the IAT
        self.hook_Import_Address_Table()
        # Initiate the registers
        self.uc.reg_write(UC_X86_REG_EDI, self.start_addr)
        self.uc.reg_write(UC_X86_REG_ESI, self.start_addr)
        self.uc.reg_write(UC_X86_REG_EDX, self.start_addr)
        self.uc.reg_write(UC_X86_REG_ECX, self.start_addr)
        self.uc.reg_write(UC_X86_REG_EBX, self.PEB_base_addr) # EBP point to the PEB address
        self.uc.reg_write(UC_X86_REG_EAX, self.TEB_base_addr) # EAX point to the TIB address
        
        # Place a debug hook
        self.uc.hook_add(UC_HOOK_CODE, self.hook_code)

        # Place a memory debug hook
        #self.uc.hook_add(UC_ERR_FETCH_UNMAPPED, self.hook_mem_invalid)

        # Start emulation
        print('[DEBUG] Starting the emulation of "%s.exe" from 0x%08x' % (self.drivename, self.start_addr))
        print()
        try:
            self.uc.emu_start(self.start_addr, self.start_addr + 500000, timeout=60 * UC_SECOND_SCALE)
        except Exception as ex:
            print('[DEBUG] Emulator crash. Reason: ' + str(ex))

        print()
        if len(self.threads) != 0:
            uniq_threads = list(dict.fromkeys(self.threads))
        else:
            uniq_threads = False
        
        if self.debug:
            print('[!] Looking for entrypoints in the threads queue')

        if uniq_threads:
            for thread_addr in uniq_threads:
                print('[!] Starting the thread ' + hex(thread_addr))
                self.execution_mode = 'thread'
                self.uc.hook_add(UC_HOOK_CODE, self.hook_code)
                self.uc.emu_start(thread_addr, self.start_addr + 100, timeout=20 * UC_SECOND_SCALE)
                #self.uc.reg_write(UC_X86_REG_EIP, add)
                print('[!] End of the thread ' + hex(thread_addr))
                self.thread_trace = []
                print()

        # Display final program's state
        final_esp = self.uc.reg_read(UC_X86_REG_ESP)
        final_ebp = self.uc.reg_read(UC_X86_REG_EBP)

        if args.dynamics:
            self.read_dynamic_imports()
            print()

        if self.stack:
            self.read_stack(final_esp, final_ebp - final_esp)
            print()

        if self.registers:
            self.read_full_regs()
            print()

        if self.handle_list:
            self.read_handle()
            print()

        if self.show_extract:
            self.display_extracts()
            print()

        if self.strings:
            self.display_strings()
            print()

        if self.buffer:
            self.display_buffer()
            print()

        if self.trace:
            print('==== Call trace ====')
            print(' →  Entrypoint')
            for elem in self.calltrace:
                print(' →  ' + elem)

        if self.out != None:
            sys.stdout.close()

def main(args):
    emul = Environment(args)
    emul.launch()

parser = argparse.ArgumentParser(description='Windows Binary Emulator')
parser.add_argument('-p', '--path', required=True, help='path to the binary file to emulate')
parser.add_argument('-b', '--breakpoint', required=False, help='pause the execution at the given address')
parser.add_argument('--trace', required=False, action="store_true", help='display the call trace of the binary')
parser.add_argument('--dump', required=False, action="store_true", help='display a full dump of the program\'s state after the execution')
parser.add_argument('--stack', required=False, action="store_true", help='display a dump of the stack after the execution')
parser.add_argument('--registers', required=False, action="store_true", help='display a dump of the regsiters after the execution')
parser.add_argument('--debug', required=False, action="store_true", help='display debug messages')
parser.add_argument('--silent', required=False, action="store_true", help='only print out the system calls')
parser.add_argument('--handle', required=False, action="store_true", help='display the list of used handles')
parser.add_argument('--extract', required=False, action="store_true", help='extract potentials payloads found in memory. Files are saved to <bin_name>_emu.out/')
parser.add_argument('--strings', required=False, action="store_true", help='extract a list of strings observed during the emulation')
parser.add_argument('--imports', required=False, action="store_true", help='UNIMPLEMENTED - display the static content of the import address table (IAT)')
parser.add_argument('--dynamics', required=False, action="store_true", help='display the list of dynamically resolved syscall')
parser.add_argument('--buffer', required=False, action="store_true", help='display the allocated buffer content')
parser.add_argument('--out', required=False, help='save the emulation output to a file')
args = parser.parse_args()
main(args)


