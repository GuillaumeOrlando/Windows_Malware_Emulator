from unicorn import *
from unicorn.x86_const import *
from capstone import *
import pefile
import struct
import sys

#TODO: Deal with SEH structure
#TODO: Randomize TEB base address
#TODO: Randomize process ID
#TODO: Randomize thread ID
#TODO: Logger
#TODO: Argparse

md = Cs(CS_ARCH_X86, CS_MODE_32)

class Environment:

    def __init__(self, path):
        self.path = path
        try:
            self.pe = pefile.PE(path)
        except OSError as e:
            print(e)
            exit -1
        except pefile.PEFormatError as e:
            print(f'Malformated or invalid PE file: {e.value}')
            exit -1

    # Log every instruction emulated
    def hook_code(self, uc, address, size, user_data):
        instruction = uc.mem_read(address, size)
        for i in md.disasm(instruction, address):
            print('> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)
            if str(i.mnemonic) == 'call':
                uc.emu_stop()


    # Read <size> bytes from the stack address <start>
    def read_stack(self, uc, start, size):
        print('=========== Stack Dump ==========')
        final_stack = uc.mem_read(start, size)
        stack_addr = start
        for x in range(0, size // 4):
            stack_addr += 4
            stack_content = final_stack[0:4]
            final_stack = final_stack[4:]
            stack_value = struct.unpack('I', stack_content)[0]
            print('0x%08x : 0x%08x' % (stack_addr, stack_value))


    # Print a dump of the current registers
    def read_full_regs(self, uc):
        print('========== Regsitry Dump ========')
        print('EAX: 0x%08x | EBP: 0x%08x' % (uc.reg_read(UC_X86_REG_EAX), uc.reg_read(UC_X86_REG_EBP)))
        print('EBX: 0x%08x | ESP: 0x%08x' % (uc.reg_read(UC_X86_REG_EBX), uc.reg_read(UC_X86_REG_ESP)))
        print('ECX: 0x%08x | ESI: 0x%08x' % (uc.reg_read(UC_X86_REG_ECX), uc.reg_read(UC_X86_REG_ESI)))
        print('EDX: 0x%08x | EDI: 0x%08x' % (uc.reg_read(UC_X86_REG_EDX), uc.reg_read(UC_X86_REG_EDI)))
        print('EIP: 0x%08x ' % uc.reg_read(UC_X86_REG_EIP))


    # Setup the process TIB structure
    def generate_Thread_Information_Block(self, uc):
        self.TEB_base_addr = 0x200000
        self.process_ID = 0x1908
        self.thread_ID = 0x10C
        self.PEB_base_addr = self.TEB_base_addr + 0x1000
        
        TEB = b''
        TEB += struct.pack("<I", 0xffffffff)                            # FS:[0x00] Structure Exception Handler (SEH)
        TEB += struct.pack("<I", (self.stack_addr + self.stack_size))   # FS:[0x04] Stack Base
        TEB += struct.pack("<I", self.stack_addr)                       # FS:[0x08] Stack Limit
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x0C] Subsystem TIB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x10] Fiber Data
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x14] Arbitrary Data Slot
        TEB += struct.pack("<I", self.TEB_base_addr)                    # FS:[0x18] Linear Address of TEB
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x1C] Environment Pointer
        TEB += struct.pack("<I", self.process_ID)                       # FS:[0x20] Process ID
        TEB += struct.pack("<I", self.thread_ID)                        # FS:[0x24] Current Thread ID
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x28] Active RPC Handle
        TEB += struct.pack("<I", 0x0)                                   # FS:[0x2C] Linear Address of the thread-local storage array
        TEB += struct.pack("<I", self.PEB_base_addr)                    # FS:[0x30] Linear Address of the Process Environment Block (PEB)
       
        page_size=4096
        m = 0x5000 % page_size
        f = page_size - m
        aligned_size = 0x5000 + f

        # Map and write the TEB in memory
        uc.mem_map(self.TEB_base_addr, aligned_size)
        uc.mem_write(self.TEB_base_addr, TEB)


    def launch(self):
        # Get header most importants fields
        self.header_image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.header_size_of_image = self.pe.OPTIONAL_HEADER.SizeOfImage
        self.header_entrypoint = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.mapped_image = self.pe.get_memory_mapped_image(ImageBase=self.header_image_base)
        self.mapped_size = (len(self.mapped_image) + 0x1000) & ~0xFFF
        self.exit_addr = 0xfffff000

        # Get virtual size needed for PE mapping
        min_offset = sys.maxsize
        virtual_size = 0
        for section in self.pe.sections:
            min_offset = section.VirtualAddress
            virtual_size += min_offset
        virtual_size += min_offset
        m = virtual_size % 4096
        f = 4096 - m
        aligned_virtual_size = virtual_size + f

        # Initialize the unicorn engine
        uc = Uc(UC_ARCH_X86, UC_MODE_32)
        
        # Map the binary in memory
        uc.mem_map(self.header_image_base, self.mapped_size)
        uc.mem_write(self.header_image_base, self.mapped_image)
        self.start_addr = self.header_entrypoint + self.header_image_base
        print('[DEBUG] Binary mapped in memory at 0x%08x' % self.header_image_base)

        # Initialize the stack
        self.stack_addr = 0x0
        self.stack_size = 0x100000
        uc.mem_map(self.stack_addr, self.stack_size)
        print('[DEBUG] Stack of 0x%x bytes starting at 0x%08x' % (self.stack_size, self.stack_addr))
        
        uc.reg_write(UC_X86_REG_ESP, self.stack_addr + self.stack_size - 0x400)
        uc.reg_write(UC_X86_REG_EBP, self.stack_addr + self.stack_size - 0x200)
        print('[DEBUG] Initial stack frame created between 0x%08x and 0x%08x' % (self.stack_size - 0x400, self.stack_size - 0x200))
       
        # Create a the TEB structure
        self.generate_Thread_Information_Block(uc)
        print('[DEBUG] Thread Information Block initiated at 0x%08x' % self.TEB_base_addr)

        # Create a the PEB structure
        # TODO

        for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
            print(entry.dll)
            for imp in entry.imports:
                print("  0x%x %s" % (imp.address, imp.name))

        # Initiate the registers
        uc.reg_write(UC_X86_REG_EDI, self.start_addr)
        uc.reg_write(UC_X86_REG_ESI, self.start_addr)
        uc.reg_write(UC_X86_REG_EDX, self.start_addr)
        uc.reg_write(UC_X86_REG_ECX, self.start_addr)
        uc.reg_write(UC_X86_REG_EBX, self.PEB_base_addr) # EBP point to the PEB address
        uc.reg_write(UC_X86_REG_EAX, self.TEB_base_addr) # EAX point to the TIB address
        
        # Place a debug hook
        uc.hook_add(UC_HOOK_CODE, self.hook_code)

        # Start emulation
        print('[DEBUG] Starting the emulation from 0x%08x' % (self.start_addr))
        print()
        uc.emu_start(self.start_addr, self.start_addr + 25)
        print()

        # Display final program's state
        final_esp = uc.reg_read(UC_X86_REG_ESP)
        final_ebp = uc.reg_read(UC_X86_REG_EBP)

        self.read_stack(uc, final_esp, final_ebp - final_esp)
        self.read_full_regs(uc)

emul = Environment(sys.argv[1])
emul.launch()
