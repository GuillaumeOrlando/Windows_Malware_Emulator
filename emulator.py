from unicorn import *
from unicorn.x86_const import *
from capstone import *
import pefile
import struct
import sys

#TODO: Deal with SEH structure
#TODO: Randomize TEB base address
#TODO: Randomize process ID
#TODO: Randomize thread ID
#TODO: Logger
#TODO: Argparse

md = Cs(CS_ARCH_X86, CS_MODE_32)

class Environment:

    def __init__(self, path):
        self.path = path
        try:
            self.pe = pefile.PE(path)
        except OSError as e:
            print(e)
            exit -1
        except pefile.PEFormatError as e:
            print(f'Malformated or invalid PE file: {e.value}')
            exit -1

    # Log every instruction emulated
    def hook_code(self, uc, address, size, user_data):
        instruction = uc.mem_read(address, size)
        for i in md.disasm(instruction, address):
            print('> Tracing intruction ' + hex(i.address), ':', i.mnemonic, i.op_str)


    # Read <size> bytes from the stack address <start>
    def read_stack(self, uc, start, size):
        print('=========== Stack Dump ==========')
        final_stack = uc.mem_read(start, size)
        stack_addr = start
        for x in range(0, size // 4):
            stack_addr += 4
            stack_content = final_stack[0:4]
            final_stack = final_stack[4:]
            stack_value = struct.unpack('I', stack_content)[0]
            print('0x%08x : 0x%08x' % (stack_addr, stack_value))


    # Print a dump of the current registers
    def read_full_regs(self, uc):
        print('========== Regsitry Dump ========')
        print('EAX: 0x%08x | EBP: 0x%08x' % (uc.reg_read(UC_X86_REG_EAX), uc.reg_read(UC_X86_REG_EBP)))
        print('EBX: 0x%08x | ESP: 0x%08x' % (uc.reg_read(UC_X86_REG_EBX), uc.reg_read(UC_X86_REG_ESP)))
        print('ECX: 0x%08x | ESI: 0x%08x' % (uc.reg_read(UC_X86_REG_ECX), uc.reg_read(UC_X86_REG_ESI)))
        print('EDX: 0x%08x | EDI: 0x%08x' % (uc.reg_read(UC_X86_REG_EDX), uc.reg_read(UC_X86_REG_EDI)))
        print('EIP: 0x%08x ' % uc.reg_read(UC_X86_REG_EIP))


    # Setup the TIB structure in memory
    def generate_Thread_Information_Block(self):
        TEB_base_addr = 0x2BB000
        process_ID = 0x1908
        thread_ID = 0x10C
        TEB = [
            0xffffffff,                         # FS:[0x00] SEH Frame
            self.stack_addr + self.stack_size,  # FS:[0x04] Stack Base
            self.stack_addr,                    # FS:[0x08] Stack Limit
            0x0,                                # FS:[0x0C] Subsystem TIB
            0x0,                                # FS:[0x10] Fiber Data
            0x0,                                # FS:[0x14] Arbitrary Data Slot
            TEB_base_addr,                      # FS:[0x18] Linear Address of TEB
            0x0,                                # FS:[0x1C] Environment Pointer
            process_ID,                         # FS:[0x20] Process ID
            thread_ID,                          # FS:[0x24] Current Thread ID
        ]
        return


    def launch(self):
        # Get header most importants fields
        self.header_image_base = self.pe.OPTIONAL_HEADER.ImageBase
        self.header_size_of_image = self.pe.OPTIONAL_HEADER.SizeOfImage
        self.header_entrypoint = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
        self.mapped_image = self.pe.get_memory_mapped_image(ImageBase=self.header_image_base)
        self.mapped_size = (len(self.mapped_image) + 0x1000) & ~0xFFF
        self.exit_addr = 0xfffff000

        # Get virtual size needed for PE mapping
        min_offset = sys.maxsize
        virtual_size = 0
        for section in self.pe.sections:
            min_offset = section.VirtualAddress
            virtual_size += min_offset
        virtual_size += min_offset
        m = virtual_size % 4096
        f = 4096 - m
        aligned_virtual_size = virtual_size + f

        # Initialize the unicorn engine
        uc = Uc(UC_ARCH_X86, UC_MODE_32)
        
        # Map the binary in memory
        uc.mem_map(self.header_image_base, self.mapped_size)
        uc.mem_write(self.header_image_base, self.mapped_image)
        print('[DEBUG] Binary mapped in memory at 0x%08x' % self.header_image_base)

        # Initialize the stack
        self.stack_addr = 0x0
        self.stack_size = 0x100000
        uc.mem_map(self.stack_addr, self.stack_size)
        print('[DEBUG] Stack of 0x%x bytes starting at 0x%08x' % (self.stack_size, self.stack_addr))
        
        uc.reg_write(UC_X86_REG_ESP, self.stack_addr + self.stack_size - 0x400)
        uc.reg_write(UC_X86_REG_EBP, self.stack_addr + self.stack_size - 0x200)
        print('[DEBUG] Initial stack frame created between 0x%08x and 0x%08x' % (self.stack_size - 0x400, self.stack_size - 0x200))
        
        # Create a TEB structure
        self.generate_Thread_Information_Block()

        # Place a debug hook
        uc.hook_add(UC_HOOK_CODE, self.hook_code)

        # Start emulation
        self.start_addr = self.header_entrypoint + self.header_image_base
        print('[DEBUG] Starting the emulation from 0x%08x' % (self.start_addr))
        print()
        uc.emu_start(self.start_addr, self.start_addr + 15)
        print()

        # Display final program's state
        final_esp = uc.reg_read(UC_X86_REG_ESP)
        final_ebp = uc.reg_read(UC_X86_REG_EBP)

        self.read_stack(uc, final_esp, final_ebp - final_esp)
        self.read_full_regs(uc)

emul = Environment(sys.argv[1])
emul.launch()
