# Syscall functions for the Windows Malware Emulator
import socket as sock

default_ret_code = 0x0
PAGE_SIZE = 4096
ALIGNED_PAGE = lambda x: (x + PAGE_SIZE - 1) & ~(PAGE_SIZE-1)
MEM_MIN = 0x00000000
MEM_MAX = 0xFFFFFFFF

# Utility functions
def clean_stack(self, num):
    for x in range(num):
        self.decstack()
    return

def add_handler(self, handle_type, handler_value):
    higher_val = [(k, self.handle[k]) for k in sorted(self.handle)][-1][0]
    last_value = int(higher_val, 16) + 1
    self.handle[hex(last_value)] = [handler_value, handle_type]
    return last_value


def get_handler(self, handle_addr):
    hval = self.handle[handle_addr][0]
    htype = self.handle[handle_addr][1]
    return 'h' + hval


def add_syscall(self, name):
    # Add an entry in the IAT_hook structure
    higher_val = list({k: self.IAT_hook[k] for k in sorted(self.IAT_hook, key=self.IAT_hook.get)}.values())[-1]
    new_value = int(higher_val, 16) + 4
    self.IAT_hook[name] = '0x%08x' % new_value
    # Add an entry in the fake Import Address Table
    higher_val = [(k, self.IAT['dynamic_import'][k]) for k in sorted(self.IAT['dynamic_import'])]
    new_addr = '0x%08x' % (int(higher_val[-1][0], 16) + 4)
    self.IAT['dynamic_import'][new_addr] = name
    # Add an entry in the non-ordered Import Address Table structure
    self.raw_IAT[new_addr] = name
    return hex(new_value)


def __set_app_type(self, args):
    at = int(args[0], 16)
    if at == 0:
        app_type = 'at=UNKNWON_APP'
    elif at == 1:
        app_type = 'at=CONSOLE_APP'
    elif at == 2:
        app_type = 'at=GUI_APP'
    else:
        app_type = 'at=INVALID_VALUE'
    ret_args = [app_type]
    clean_stack(self, len(args))
    return default_ret_code, ret_args


def GetStartupInfoA(self, args):
    lpStartupInfo = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpStartupInfo=' + hex(lpStartupInfo)


def GetModuleHandleA(self, args):
    lpModuleName = int(args[0], 16)
    if lpModuleName == 0x0:
        lpModuleName = '"' + self.drivename + '"'
        ret = add_handler(self, 'module', self.drivename)
    else:
        ret = add_handler(self, 'module', lpModuleName)
        lpModuleName = str(hex(lpModuleName))
    clean_stack(self, len(args))
    return ret, 'lpModuleName=' + lpModuleName


def OpenSCManagerA(self, args):
    lpMachineName = int(args[0], 16)
    lpDatabaseName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    if lpMachineName == 0x0:
        lpMachineName = 'LOCAL_COMPUTER'
    else:
        lpMachineName = str(hex(lpMachineName))
    if lpDatabaseName == 0x0:
        lpDatabaseName = 'SERVICE_ACTIVE_DATABASE'
    else:
        lpDatabaseName = str(hex(lpMachineName))
    ret = add_handler(self, 'service_control_manager', lpDatabaseName)
    clean_stack(self, len(args))
    return ret, 'lpMachineName=' + lpMachineName + ', lpDatabaseName=' + lpDatabaseName + ', dwDesiredAccess=' + hex(dwDesiredAccess)


def OpenServiceA(self, args):
    hSCManager = int(args[0], 16)
    lpServiceName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    service = self.uc.mem_read(lpServiceName, 1000).split(b'\x00')[0].decode()
    ret = add_handler(self, 'service', service)
    clean_stack(self, len(args))
    return ret, 'hSCManager=' + hex(hSCManager) + ', lpServiceName="' + service + '", dwDesiredAccess=' + hex(dwDesiredAccess)
    

def GetSystemTimeAsFileTime(self, args):
    timestruct = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpSystemTimeAsFileTime=' + hex(timestruct)


def GetCurrentThreadId(self, args):
    tid = self.thread_ID
    return tid, ''


def GetCurrentProcessId(self, args):
    pid = self.process_ID
    return pid, ''


def IsProcessorFeaturePresent(self, args):
    feature = int(args[0], 16)
    if feature == 25:
        feature_type = 'PF_ARM_64BITS_LOADSTORE_ATOMIC'
    elif feature == 24:
        feature_type = 'PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE'
    elif feature == 26:
        feature_type = 'PF_ARM_EXTERNAL_CACHE_AVAILABLE'
    elif feature == 27:
        feature_type = 'PF_ARM_FMAC_INSTRUCTION_AVAILABLE'
    elif feature == 18:
        feature_type = 'PF_ARM_VFP_32_REGISTERS_AVAILABLE'
    elif feature == 7:
        feature_type = 'PF_3DNOW_INSTRUCTION_AVAILABLE'
    elif feature == 16:
        feature_type = 'PF_CHANNELS_ENABLED'
    elif feature == 2:
        feature_type = 'PF_COMPARE_EXCHANGE_DOUBLE'
    elif feature == 14:
        feature_type = 'PF_COMPARE_EXCHANGE128'
    else:
        feature_type = 'UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'ProcessorFeature=' + feature_type


def GetProcAddress(self, args):
    hModule = get_handler(self, args[0])
    lpProcName_addr = int(args[1], 16)
    lpProcName = self.uc.mem_read(lpProcName_addr, 1000).split(b'\x00')[0].decode() 
    func_addr = add_syscall(self, lpProcName)
    clean_stack(self, len(args))
    self.dynamics.append([func_addr, lpProcName])
    return int(func_addr, 16), 'hModule=' + hModule + ', lpProcName="' + lpProcName + '"'


def LoadLibraryA(self, args):
    addr = int(args[0], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName=' + lpLibFileName


def LoadLibraryExW(self, args):
    addr = int(args[0], 16)
    hFile = int(args[1], 16)
    flags = int(args[2], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00\x00\x00\x00')[0].decode() # Should be enought to get the shared library name
    if flags == 0x800:
        dwFlags = 'LOAD_LIBRARY_SEARCH_SYSTEM32'
    elif flags == 0x1:
        dwFlags = 'DONT_RESOLVE_DLL_REFERENCES'
    elif flags == 0x10:
        dwFlags = 'LOAD_IGNORE_CODE_AUTHZ_LEVEL'
    elif flags == 0x2:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE'
    elif flags == 0x40:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE'
    elif flags == 0x20:
        dwFlags = 'LOAD_LIBRARY_AS_IMAGE_RESOURCE'
    elif flags == 0x200:
        dwFlags = 'LOAD_LIBRARY_SEARCH_APPLICATION_DIR'
    elif flags == 0x1000:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DEFAULT_DIRS'
    elif flags == 0x100:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR'
    elif flags == 0x400:
        dwFlags = 'LOAD_LIBRARY_SEARCH_USER_DIRS'
    elif flags == 0x8:
        dwFlags = 'LOAD_WITH_ALTERED_SEARCH_PATH'
    elif flags == 0x80:
        dwFlags = 'LOAD_LIBRARY_REQUIRE_SIGNED_TARGET'
    elif flags == 0x2000:
        dwFlags = 'LOAD_LIBRARY_SAFE_CURRENT_DIRS'
    else:
        dwFlags = 'UNKNWON'
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName="' + lpLibFileName + '", hFile=' + hex(hFile) + ', dwFlags=' + dwFlags

def CreateMutexA(self, args):
    lpMutexAttributes = int(args[0], 16)
    bInitialOwner = int(args[1], 16)
    lpName_addr = int(args[2], 16)
    lpName = self.uc.mem_read(lpName_addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'mutex', lpName)
    clean_stack(self, len(args))
    return handle, 'lpMutexAttributes=' + hex(lpMutexAttributes) + ', bInitialOwner=' + hex(bInitialOwner) + ', lpName="' + lpName + '"'


def HeapCreate(self, args):
    flOptions = int(args[0], 16)
    dwInitialSize = int(args[1], 16)
    dwMaximumSize = int(args[2], 16)
    # Todo: Allocate real memory
    addr = 0x1234
    handle = add_handler(self, 'heap', addr)
    clean_stack(self, len(args))
    return handle, 'flOptions=' + hex(flOptions) + ', dwInitialSize=' + hex(dwInitialSize) + ', dwMaximumSize=' + hex(dwMaximumSize) + ''


def HeapAlloc(self, args):
    hHeap = int(args[0], 16)
    dwFlags = int(args[1], 16)
    lpMem = int(args[2], 16)
    # Todo realocate heap
    ptr = 0x1234
    clean_stack(self, len(args))
    return ptr, 'hHeap=' + hex(hHeap) + ', dwFlags=' + hex(dwFlags) + ', lpMem=' + hex(lpMem) + ''


def mem_allocate(address, size):
    #print(address, size)
    return


def VirtualAlloc(self, args):
    lpAddress = int(args[0], 16)
    dwSize = int(args[1], 16)
    flAllocationType = int(args[2], 16)
    flProtect = int(args[3], 16)

    # Todo: Allocate real memory
    mem_obj = mem_allocate(lpAddress, dwSize)

    addr = 0x4321
    clean_stack(self, len(args))
    return addr, 'lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', flAllocationType=' + hex(flAllocationType) + ', flProtect=' + hex(flProtect) + ''


def GetStdHandle(self, args):
    nStdHandle = int(args[0], 16)
    if nStdHandle == 0xfffffff6:
        handletype = 'STD_INPUT_HANDLER'
    elif nStdHandle == 0xfffffff5:
        handletype = 'STD_OUTPUT_HANDLER'
    elif nStdHandle == 0xfffffff4:
        handletype = 'STD_ERROR_HANDLER'
    else:
        handletype = hex(nStdHandle)
    handle = add_handler(self, 'STD', handletype)
    clean_stack(self, len(args))
    return handle, 'nStdHandle=' + handletype


def GetFileType(self, args):
    hFile = int(args[0], 16)
    clean_stack(self, len(args))
    val = get_handler(self, args[0])
    ret = 0x0000
    if 'STD' in val:
        ret = 0x0001
    return ret, 'hFile=' + hex(hFile)


def SetHandleCount(self, args):
    uNumber = int(args[0], 16)
    clean_stack(self, len(args))
    ret = len(self.handle) - 1
    return ret, 'uNumber=' + hex(uNumber)


def GetACP(self, args):
    ret = 28592 # 	ISO 8859-2 Central European; Central European (ISO)
    return ret, '' 


def GetModuleFileNameA(self, args):
    hModule = int(args[0], 16)
    lpFilename = int(args[1], 16)
    nSize = int(args[2], 16)
    self.uc.mem_write(lpFilename, bytes(self.drivename.encode()))
    fname = self.uc.mem_read(lpFilename, 1000).split(b'\x00')[0].decode() 
    ret = len(self.drivename)
    clean_stack(self, len(args))
    return ret, 'hModule=' + hex(hModule) + ', lpFilename="' + fname + '", nSize=' + hex(nSize)


def EnterCriticalSection(self, args):
    lpCriticalSection = int(args[0], 16)
    clean_stack(self, len(args))
    return None, 'lpCriticalSection=' + hex(lpCriticalSection)


def htons(self, args):
    hostshort = int(args[0], 16)
    clean_stack(self, len(args))
    byte_net = sock.htons(hostshort)
    return byte_net, 'hostshort=' + str(int(hostshort))


def connect(self, args):
    s = int(args[0], 16)
    name = int(args[1], 16)
    namelen = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 's=' + hex(s) + ', name=' + hex(name) + ', namelen=' + hex(namelen)


def InetPtonW(self, args):
    familly = int(args[0], 16)
    pszAddrString = int(args[1], 16)
    pAddrBuf = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 'familly=' + hex(familly) + ', pszAddrString=' + hex(pszAddrString) + ', pAddrBuf=' + hex(pAddrBuf)


def CreateFileA(self, args):
    lpFileName = int(args[0], 16)
    dwDesiredAccess = int(args[1], 16)
    dwShareMode = int(args[2], 16)
    lpSecurityAttributes = int(args[3], 16)
    dwCreationDisposition = int(args[4], 16)
    dwFlagsAndAttributes = int(args[5], 16)
    hTemplateFile = int(args[6], 16)
    
    fname = self.uc.mem_read(lpFileName, 1000).split(b'\x00')[0].decode() 

    if dwShareMode == 0:
        share = 'BLOCK_MODE'
    elif dwShareMode == 1:
        share = 'FILE_SHARE_READ'
    elif dwShareMode == 2:
        share = 'FILE_SHARE_WRITE'
    elif dwShareMode == 4:
        share = 'FILE_SHARE_DELETE'

    if dwCreationDisposition == 1:
        creation = 'CREATE_NEW'
    if dwCreationDisposition == 2:
        creation = 'CREATE_ALWAYS'
    if dwCreationDisposition == 3:
        creation = 'OPEN_EXISTING'
    if dwCreationDisposition == 4:
        creation = 'OPEN_ALWAYS'
    if dwCreationDisposition == 5:
        creation = 'TRUNCATE_EXISTING'

    clean_stack(self, len(args))
    ret = 0xffffffff
    return ret, 'lpFileName="' + fname + '", ' + 'dwDesiredAccess=' + hex(dwDesiredAccess) + ', ' + 'dwShareMode=' + share + ', ' + 'lpSecurityAttributes=' + hex(lpSecurityAttributes) + ', ' + 'dwCreationDisposition=' + creation + ', ' + 'dwFlagsAndAttributes=' + hex(dwFlagsAndAttributes) + ', ' + 'hTemplateFile=' + hex(hTemplateFile)


def ExitProcess(self, args):
    uExitCode = int(args[0], 16)
    return 0xdeadbade, 'EXIT'

