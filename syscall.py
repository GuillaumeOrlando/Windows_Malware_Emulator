# Syscall functions for the Windows Malware Emulator
import socket as sock
import pefile
from unicorn.x86_const import *
from capstone import *

default_ret_code = 0x0
PAGE_SIZE = 0x1000
ALIGNED_PAGE = lambda x: (x + PAGE_SIZE - 1) & ~(PAGE_SIZE-1)
HEAP_MIN = 0x60000000
HEAP_MAX = 0x90000000
VMEM_MIN = 0x00100000
VMEM_MAX = 0xFFFFFFFF

# Utility functions
def clean_stack(self, num):
    for x in range(num):
        self.decstack()
    return

def pe_header(self, data):
    if data[:2] == b'MZ':
        return True
    else:
        return False

def add_handler(self, handle_type, handler_value):
    higher_val = [(k, self.handle[k]) for k in sorted(self.handle)][-1][0]
    last_value = int(higher_val, 16) + 1
    self.handle[hex(last_value)] = [handler_value, handle_type]
    return last_value


def get_handler(self, handle_addr):
    hval = self.handle[handle_addr][0]
    htype = self.handle[handle_addr][1]
    if isinstance(hval, bytes):
        return hval
    return 'h' + str(hval)


def get_handler_from_value(self, value):
    found = False
    handle = None
    for elem in self.handle:
        hval = self.handle[elem][0]
        if str(hval) == str(value):
            found = True
            handle = elem
            break
    return  [found, handle]


def add_syscall(self, name):
    # Add an entry in the IAT_hook structure
    higher_val = list({k: self.IAT_hook[k] for k in sorted(self.IAT_hook, key=self.IAT_hook.get)}.values())[-1]
    new_value = int(higher_val, 16) + 4
    self.IAT_hook[name] = '0x%08x' % new_value
    # Add an entry in the fake Import Address Table
    higher_val = [(k, self.IAT['dynamic_import'][k]) for k in sorted(self.IAT['dynamic_import'])]
    new_addr = '0x%08x' % (int(higher_val[-1][0], 16) + 4)
    self.IAT['dynamic_import'][new_addr] = name
    # Add an entry in the non-ordered Import Address Table structure
    self.raw_IAT[new_addr] = name
    return hex(new_value)


class Heap():
    def __init__(self, address, size, data_size):
        self.size = size
        self.address = address
        self.data_size = data_size
        self.data_address = address + PAGE_SIZE

        def is_chunk(self, address, size):
            if address >= self.data_address and ((address + size) <= (self.data_address + self.data_size)):
                return True
            else:
                return False


class VirtualMemory():
    def __init__(self, address, size, data_size):
        self.size = size
        self.address = address
        self.data_size = data_size
        self.data_address = address + PAGE_SIZE


def alloc_heap(self, size):
    total_chunk_size = PAGE_SIZE + ALIGNED_PAGE(size) + PAGE_SIZE
    chunk = None
    for address in range(HEAP_MIN, HEAP_MAX, PAGE_SIZE):
        try:
            self.uc.mem_map(address, total_chunk_size)
            chunk = Heap(address, total_chunk_size, size)
            if self.debug:
                print('[!] Allocating a ' + hex(chunk.data_size) + ' bytes chunk at address ' + hex(chunk.data_address))
            break
        except:
            continue
    if chunk == None:
        return False
    self.chunks.append(chunk)
    return chunk.data_address


def alloc_vmem(self, size, req_address):
    total_mem_size = PAGE_SIZE + ALIGNED_PAGE(size) + PAGE_SIZE
    mem = None
    if req_address == 0x0:
        for address in range(VMEM_MIN, VMEM_MAX, PAGE_SIZE):
            try:
                self.uc.mem_map(address, total_mem_size)
                vmem = VirtualMemory(address, total_mem_size, size)
                if self.debug:
                    print('[!] Allocating ' + hex(vmem.data_size) + ' bytes of memory at address ' + hex(vmem.data_address))
                break
            except:
                continue
        if vmem == None:
            return False
        self.virtual_memory.append(vmem)
        return vmem.data_address
    else:
        try:
            self.uc.mem_map(req_address, total_mem_size)
        except:
#            alloc_vmem(self, size, 0x0)
            return req_address


def __set_app_type(self, args):
    at = int(args[0], 16)
    if at == 0:
        app_type = 'at=UNKNWON_APP'
    elif at == 1:
        app_type = 'at=CONSOLE_APP'
    elif at == 2:
        app_type = 'at=GUI_APP'
    else:
        app_type = 'at=INVALID_VALUE'
    ret_args = [app_type]
    clean_stack(self, len(args))
    return default_ret_code, ret_args


def GetStartupInfoA(self, args):
    lpStartupInfo = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpStartupInfo=' + hex(lpStartupInfo)


def GetModuleHandleA(self, args):
    lpModuleName = int(args[0], 16)
    if lpModuleName == 0x0:
        lpModuleName = '"' + self.drivename + '"'
        ret = add_handler(self, 'module', self.drivename)
    else:
        try:
            lpModuleName = self.uc.mem_read(lpModuleName, 1000).split(b'\x00')[0].decode()
        except:
            lpModuleName = str(hex(lpModuleName))
        ret = add_handler(self, 'module', lpModuleName)
    clean_stack(self, len(args))
    return ret, 'lpModuleName=' + lpModuleName


def GetModuleHandleW(self, args):
    lpModuleName = int(args[0], 16)
    if lpModuleName == 0x0:
        lpModuleName = '"' + self.drivename + '"'
        ret = add_handler(self, 'module', self.drivename)
    else:
        ret = add_handler(self, 'module', lpModuleName)
        lpModuleName = str(hex(lpModuleName))
    clean_stack(self, len(args))
    return ret, 'lpModuleName=' + lpModuleName


def VirtualProtect(self, args):
    lpAddress = int(args[0], 16)
    dwSize = int(args[1], 16)
    flNewProtect = int(args[2], 16)
    lpflOldProtect = int(args[3], 16)
    clean_stack(self, len(args))
    return 0x1, 'lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', flNewProtect=' + hex(flNewProtect) + ', lpflOldProtect=' + hex(lpflOldProtect)


def OpenSCManagerA(self, args):
    lpMachineName = int(args[0], 16)
    lpDatabaseName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    if lpMachineName == 0x0:
        lpMachineName = 'LOCAL_COMPUTER'
    else:
        lpMachineName = str(hex(lpMachineName))
    if lpDatabaseName == 0x0:
        lpDatabaseName = 'SERVICE_ACTIVE_DATABASE'
    else:
        lpDatabaseName = str(hex(lpMachineName))
    ret = add_handler(self, 'service_control_manager', lpDatabaseName)
    clean_stack(self, len(args))
    return ret, 'lpMachineName=' + lpMachineName + ', lpDatabaseName=' + lpDatabaseName + ', dwDesiredAccess=' + hex(dwDesiredAccess)


def OpenServiceA(self, args):
    hSCManager = int(args[0], 16)
    lpServiceName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    service = self.uc.mem_read(lpServiceName, 1000).split(b'\x00')[0].decode()
    ret = add_handler(self, 'service', service)
    clean_stack(self, len(args))
    return ret, 'hSCManager=' + hex(hSCManager) + ', lpServiceName="' + service + '", dwDesiredAccess=' + hex(dwDesiredAccess)
    

def CreateServiceA(self, args):
    hSCManager = int(args[0], 16)
    lpServiceName = int(args[1], 16)
    lpDisplayName = int(args[2], 16)
    dwDesiredAccess = int(args[3], 16)
    dwServiceType = int(args[4], 16)
    dwStartType = int(args[5], 16)
    dwErrorControl = int(args[6], 16)
    lpBinaryPathName = int(args[7], 16)
    lpLoadOrderGroup = int(args[8], 16)
    lpdwTagId = int(args[9], 16)
    lpDependencies = int(args[10], 16)
    lpServiceStartName = int(args[11], 16)
    lpPassword = int(args[12], 16)
    handle = get_handler(self, args[0])
    serviceName = self.uc.mem_read(lpServiceName, 1000).split(b'\x00')[0].decode()
    displayName = self.uc.mem_read(lpDisplayName, 1000).split(b'\x00')[0].decode()
    binPath = self.uc.mem_read(lpBinaryPathName, 1000).split(b'\x00')[0].decode()
    if dwServiceType == 0x4:
        serviceType = 'SERVICE_ADAPTER'
    elif dwServiceType == 0x2:
        serviceType = 'SERVICE_FILE_SYSTEM_DRIVER'
    elif dwServiceType == 0x1:
        serviceType = 'SERVICE_KERNEL_DRIVER'
    elif dwServiceType == 0x8:
        serviceType = 'SERVICE_RECONIZER_DRIVER'
    elif dwServiceType == 0x10:
        serviceType = 'SERVICE_WIN32_OWN_PROCESS'
    elif dwServiceType == 0x20:
        serviceType = 'SERVICE_WIN32_SHARE_PROCESS'
    elif dwServiceType == 0x50:
        serviceType = 'SERVICE_USER_OWN_PROCESS'
    elif dwServiceType == 0x60:
        serviceType = 'SERVICE_USER_SHARE_PROCESS'
    else:
        serviceType = 'SERVICE_UNKNWON'
    if dwStartType == 0x2:
        startType = 'SERVICE_AUTO_START'
    elif dwStartType == 0x0:
        startType = 'SERVICE_BOOT_STRAT'
    elif dwStartType == 0x3:
        startType = 'SERVICE_DEMAND_STRAT'
    elif dwStartType == 0x4:
        startType = 'SERVICE_DISABLED'
    elif dwStartType == 0x1:
        startType = 'SERVICE_SYSTEM_START'
    else:
        startType = 'SERVICE_UNKNOWN'
    if dwErrorControl == 0x3:
        errorControl = 'SERVICE_ERROR_CRITICAL'
    elif dwErrorControl == 0x0:
        errorControl = 'SERVICE_ERROR_IGNORE'
    elif dwErrorControl == 0x1:
        errorControl = 'SERVICE_ERROR_NORMAL'
    elif dwErrorControl == 0x2:
        errorControl = 'SERVICE_ERROR_SEVERE'
    else:
        errorControl = 'SERVICE_ERROR_UNKNOWN'
    clean_stack(self, len(args))
    ret = add_handler(self, 'service', serviceName)
    return ret, 'hSCManager=' + handle + ', lpServiceName="' + serviceName + '", lpDisplayName="' + displayName + '", dwDesiredAccess=' + hex(dwDesiredAccess) + ', dwServiceType=' + serviceType + ', dwStartType=' + startType + ', dwErrorControl=' + errorControl + ', lpBinaryPathName="' + binPath + '", lpLoadOrderGroup=' + hex(lpLoadOrderGroup) + ', lpdwTagId=' + hex(lpdwTagId) + ', lpDependencies=' + hex(lpDependencies) + ', lpServiceStartName=' + hex(lpServiceStartName) + ', lpPassword=' + hex(lpPassword)


def FindResourceA(self, args):
    hModule = int(args[0], 16)
    lpName = int(args[1], 16)
    lpType = int(args[2], 16)
    if hModule == 0x0:
        handle = '"' + self.shortname + '"'
    else:
        handle = get_handler(self, args[0])
    res_handle = None

    if hasattr(self.pe, "DIRECTORY_ENTRY_RESOURCE"):
        for resource_type in self.pe.DIRECTORY_ENTRY_RESOURCE.entries:
            try:
                if resource_type.name is not None:
                    name = str(resource_type.name)
                else:
                    name = str(pefile.RESOURCE_TYPE.get(resource_type.struct.Id))
                if hasattr(resource_type, "directory"):
                    for resource_id in resource_type.directory.entries:
                        if resource_id.id == None:
                            if resource_id.name == lpName or str(resource_id.name) == self.uc.mem_read(lpName, 1000).split(b'\x00')[0].decode():
                                res_handle = resource_id
                                break
                        if resource_id.name == None: 
                            if resource_id.id == lpName or resource_id.name == lpName:
                                res_handle = resource_id
                                break
            except:
                continue

    if res_handle != None:
        ret = add_handler(self, 'resource_entry', name)
        self.resources[ret] = res_handle
    else:
        ret = 0x0
    clean_stack(self, len(args))
    if res_handle.id == None:
        lpName = str(res_handle.name)
    elif res_handle.name == None:
        lpName = str(res_handle.id)
    else:
        lpName = hex(lpName)
    return ret, 'hModule=' + handle + ', ' + 'lpName=' + lpName + ', ' + 'lpType=' + hex(lpType)


def LoadResource(self, args):
    hModule = int(args[0], 16)
    hResInfo = int(args[1], 16)
    if hModule != 0x0:
        module = get_handler(self, args[0])
    else:
        module = self.shortname
    res = self.resources[hResInfo]
    if hasattr(res, "directory"):
        for resource_lang in res.directory.entries:
            data = self.pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
            #print(data)
            chunk_ptr = alloc_heap(self, len(data))
            self.uc.mem_write(chunk_ptr, data)
            a = self.uc.mem_read(chunk_ptr, len(data)) 
            #print(a)
            ret = chunk_ptr#add_handler(self, 'resource_data', chunk_ptr)
            break
    else:
        ret = 0x0
    if self.debug and pe_header(self, data):
        print('[!] PE Executable extracted from resources')
    clean_stack(self, len(args))
    return ret, 'hModule="' + module + '", ' + 'hResInfo=' + hex(hResInfo)


def LockResource(self, args):
    hResData = int(args[0], 16)
    clean_stack(self, len(args))
    return hResData, 'hResData=' + hex(hResData)


def FreeResource(self, args):
    hResData = int(args[0], 16)
    clean_stack(self, len(args))
    return 0x0, 'hResData=' + hex(hResData)


def SizeofResource(self, args):
    hModule = int(args[0], 16)
    hResInfo = int(args[1], 16)
    if hModule != 0x0:
        module = get_handler(self, args[0])
    else:
        module = self.shortname
    data = ''
    res = self.resources[hResInfo]
    if hasattr(res, "directory"):
        for resource_lang in res.directory.entries:
            data = self.pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
            break
    ret = len(data)
    clean_stack(self, len(args))
    return ret, 'hModule="' + module + '", ' + 'hResInfo=' + hex(hResInfo)


def WriteFile(self, args):
    hFile = int(args[0], 16)
    lpBuffer = int(args[1], 16)
    nNumberOfBytesToWrite = int(args[2], 16)
    lpNumberOfBytesWritten = int(args[3], 16)
    lpOverlapped = int(args[4], 16)
    module = get_handler(self, args[0])
    print(lpBuffer)
    try:
        buff = get_handler(self, lpBuffer)
    except:
        buff = self.uc.mem_read(lpBuffer, nNumberOfBytesToWrite)
    self.extracts[module] = buff
    clean_stack(self, len(args))
    return 0x1, 'hFile="' + module + '", ' + 'lpBuffer=' + hex(lpBuffer) + ', nNumberOfBytesToWrite=' + hex(nNumberOfBytesToWrite) + ', lpNumberOfBytesWritten=' + hex(lpNumberOfBytesWritten) + ', lpOverlapped=' + hex(lpOverlapped)


def StartServiceA(self, args):
    hService = int(args[0], 16)
    dwNumServiceArgs = int(args[1], 16)
    lpServiceArgVector = int(args[2], 16)
    handle = get_handler(self, args[0])
    if lpServiceArgVector == 0x0:
        vector = str(hex(lpServiceArgVector))
    else:
        vector = self.uc.mem_read(lpServiceArgVector, 1000).split(b'\x00')[0].decode()
    clean_stack(self, len(args))
    return 0x1, 'hService=' + handle + ', dwNumServiceArgs=' + hex(dwNumServiceArgs) + ', lpServiceArgVector=' + vector


def ControlService(self, args):
    hService = int(args[0], 16)
    dwControl = int(args[1], 16)
    lpServiceStatus = int(args[2], 16)
    handle = get_handler(self, args[0])
    if dwControl == 0x3:
        control = 'SERVICE_CONTROL_CONTINUE'
    elif dwControl == 0x4:
        control = 'SERVICE_CONTROL_INTERROGATE'
    elif dwControl == 0x7:
        control = 'SERVICE_CONTROL_NETBINDADD'
    elif dwControl == 0xA:
        control = 'SERVICE_CONTROL_NETBINDDISABLE'
    elif dwControl == 0x9:
        control = 'SERVICE_CONTROL_NETBINDENABLE'
    elif dwControl == 0x8:
        control = 'SERVICE_CONTROL_NETBINDREMOVE'
    elif dwControl == 0x6:
        control = 'SERVICE_CONTROL_PARAMCHANGE'
    elif dwControl == 0x2:
        control = 'SERVICE_CONTROL_PAUSE'
    elif dwControl == 0x1:
        control = 'SERVICE_CONTROL_STOP'
    else:
        control = 'SERVICE_CONTROL_UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'hService=' + handle + ', ' + 'dwControl=' + control + ', ' + 'lpServiceStatus=' + hex(lpServiceStatus)


def GetSystemTimeAsFileTime(self, args):
    timestruct = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpSystemTimeAsFileTime=' + hex(timestruct)


def GetCurrentThreadId(self, args):
    tid = self.thread_ID
    return tid, ''


def GetCurrentProcessId(self, args):
    pid = self.process_ID
    return pid, ''


def IsProcessorFeaturePresent(self, args):
    feature = int(args[0], 16)
    if feature == 25:
        feature_type = 'PF_ARM_64BITS_LOADSTORE_ATOMIC'
    elif feature == 24:
        feature_type = 'PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE'
    elif feature == 26:
        feature_type = 'PF_ARM_EXTERNAL_CACHE_AVAILABLE'
    elif feature == 27:
        feature_type = 'PF_ARM_FMAC_INSTRUCTION_AVAILABLE'
    elif feature == 18:
        feature_type = 'PF_ARM_VFP_32_REGISTERS_AVAILABLE'
    elif feature == 7:
        feature_type = 'PF_3DNOW_INSTRUCTION_AVAILABLE'
    elif feature == 16:
        feature_type = 'PF_CHANNELS_ENABLED'
    elif feature == 2:
        feature_type = 'PF_COMPARE_EXCHANGE_DOUBLE'
    elif feature == 14:
        feature_type = 'PF_COMPARE_EXCHANGE128'
    else:
        feature_type = 'UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'ProcessorFeature=' + feature_type


#def WinHttpOpen(self, args):
#    pszAgentW = get_handler(self, args[0])
#    dwAccessType = get_handler(self, args[1])
#    pszProxyW = get_handler(self, args[2])
#    pszProxyBypassW = get_handler(self, args[3])
#    dwFlags = get_handler(self, args[4])
#    clean_stack(self, len(args))
#    return 0x1, 'ProcessorFeature=' + feature_type


def GetProcAddress(self, args):
    hModule = get_handler(self, args[0])
    lpProcName_addr = int(args[1], 16)
    lpProcName = self.uc.mem_read(lpProcName_addr, 1000).split(b'\x00')[0].decode() 
    func_addr = add_syscall(self, lpProcName)
    clean_stack(self, len(args))
    self.dynamics.append([func_addr, lpProcName])
    return int(func_addr, 16), 'hModule=' + hModule + ', lpProcName="' + lpProcName + '"'


def LoadLibraryA(self, args):
    addr = int(args[0], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName=' + lpLibFileName


def LoadLibraryExW(self, args):
    addr = int(args[0], 16)
    hFile = int(args[1], 16)
    flags = int(args[2], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00\x00\x00\x00')[0].decode()
    if flags == 0x800:
        dwFlags = 'LOAD_LIBRARY_SEARCH_SYSTEM32'
    elif flags == 0x1:
        dwFlags = 'DONT_RESOLVE_DLL_REFERENCES'
    elif flags == 0x10:
        dwFlags = 'LOAD_IGNORE_CODE_AUTHZ_LEVEL'
    elif flags == 0x2:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE'
    elif flags == 0x40:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE'
    elif flags == 0x20:
        dwFlags = 'LOAD_LIBRARY_AS_IMAGE_RESOURCE'
    elif flags == 0x200:
        dwFlags = 'LOAD_LIBRARY_SEARCH_APPLICATION_DIR'
    elif flags == 0x1000:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DEFAULT_DIRS'
    elif flags == 0x100:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR'
    elif flags == 0x400:
        dwFlags = 'LOAD_LIBRARY_SEARCH_USER_DIRS'
    elif flags == 0x8:
        dwFlags = 'LOAD_WITH_ALTERED_SEARCH_PATH'
    elif flags == 0x80:
        dwFlags = 'LOAD_LIBRARY_REQUIRE_SIGNED_TARGET'
    elif flags == 0x2000:
        dwFlags = 'LOAD_LIBRARY_SAFE_CURRENT_DIRS'
    else:
        dwFlags = 'UNKNWON'
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName="' + lpLibFileName + '", hFile=' + hex(hFile) + ', dwFlags=' + dwFlags

def CreateMutexA(self, args):
    lpMutexAttributes = int(args[0], 16)
    bInitialOwner = int(args[1], 16)
    lpName_addr = int(args[2], 16)
    lpName = self.uc.mem_read(lpName_addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'mutex', lpName)
    clean_stack(self, len(args))
    return handle, 'lpMutexAttributes=' + hex(lpMutexAttributes) + ', bInitialOwner=' + hex(bInitialOwner) + ', lpName="' + lpName + '"'


def OpenMutexA(self, args):
    dwDesiredAccess = int(args[0], 16)
    bInheritHandle = int(args[1], 16)
    lpName = int(args[2], 16)
    name = self.uc.mem_read(lpName, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    found, handle = get_handler_from_value(self, name)
    if found:
        ret = handle
    else:
        ret = 0x0
    clean_stack(self, len(args))
    return ret, 'dwDesiredAccess=' + hex(dwDesiredAccess) + ', bInheritHandle=' + hex(bInheritHandle) + ', lpName="' + name + '"'


def HeapCreate(self, args):
    flOptions = int(args[0], 16)
    dwInitialSize = int(args[1], 16)
    dwMaximumSize = int(args[2], 16)
    # TODO: Allocate real memory
    addr = 0x1234
    handle = add_handler(self, 'heap', addr)
    clean_stack(self, len(args))
    return handle, 'flOptions=' + hex(flOptions) + ', dwInitialSize=' + hex(dwInitialSize) + ', dwMaximumSize=' + hex(dwMaximumSize) + ''


def GlobalAlloc(self, args):
    uFlags = int(args[0], 16)
    dwBytes = int(args[1], 16)
    chunk_ptr = alloc_heap(self, dwBytes)
    clean_stack(self, len(args))
    return chunk_ptr, 'uFlags=' + hex(uFlags) + ', dwBytes=' + hex(dwBytes)


def GlobalLock(self, args):
    hMem = int(args[0], 16)
    clean_stack(self, len(args))
    return hMem, 'hMem=' + hex(hMem)


def GetSystemDirectoryA(self, args):
    lpBuffer = int(args[0], 16)
    uSize = int(args[1], 16)
    sys = "C:\\Windows\\System32"
    self.uc.mem_write(lpBuffer, bytes(sys.encode()))
    ptr = self.uc.mem_read(lpBuffer, 4)
    clean_stack(self, len(args))
    return len(sys), 'lpBuffer=' + hex(lpBuffer) + ', uSize=' + hex(uSize)


def CreateThread(self, args):
    lpThreadAttributes = int(args[0], 16)
    dwStackSize = int(args[1], 16)
    lpStartAddress = int(args[2], 16)
    lpParameter = int(args[3], 16)
    dwCreationFlags = int(args[4], 16)
    lpThreadId = int(args[5], 16)
    if dwCreationFlags == 0x0:
        start = 'IMEDIATE'
    elif dwCreatinFalgs == 0x4:
        start = 'CREATE_SUSPENDED'
    elif dwCreatinFalgs == 0x1000:
        start = 'STACK_SIZE_PARAM_IS_A_RESERVATION'
    else:
        start = 'UNKNOWN'
    found, handle = get_handler_from_value(self, lpStartAddress)
    if found:
        ret = int(handle, 16)
    else:
        ret = add_handler(self, 'thread', lpStartAddress)
    clean_stack(self, len(args))
    original_eip = self.uc.reg_read(UC_X86_REG_EIP)
    self.threads.append(lpStartAddress)
    return 'THREAD', 'lpThreadAttributes=' + hex(lpThreadAttributes) + ', ' + 'dwStackSize=' + hex(dwStackSize) + ', ' + 'lpStartAddress=' + hex(lpStartAddress) + ', ' + 'lpParameter=' + hex(lpParameter) + ', ' + 'dwCreationFlags=' + start + ', ' + 'lpThreadId=' + hex(lpThreadId)


def HeapAlloc(self, args):
    hHeap = int(args[0], 16)
    dwFlags = int(args[1], 16)
    dwBytes = int(args[2], 16)
    chunk_ptr = alloc_heap(self, dwBytes)
    clean_stack(self, len(args))
    return chunk_ptr, 'hHeap=' + hex(hHeap) + ', dwFlags=' + hex(dwFlags) + ', dwBytes=' + hex(dwBytes)


def malloc(self, args):
    size = int(args[0], 16)
    chunk_ptr = alloc_heap(self, size)
    clean_stack(self, len(args))
    return chunk_ptr, 'size=' + hex(size)

def DebugBreak(self, args):
    return None, ''

def calloc(self, args):
    number = int(args[0], 16)
    size = int(args[1], 16)
    chunk_ptr = alloc_heap(self, size)
    clean_stack(self, len(args))
    return chunk_ptr, 'number=' + hex(number) + ', size=' + hex(size)


def VirtualAlloc(self, args):
    lpAddress = int(args[0], 16)
    dwSize = int(args[1], 16)
    flAllocationType = int(args[2], 16)
    flProtect = int(args[3], 16)
    mem_addr = alloc_vmem(self, dwSize, lpAddress)
    clean_stack(self, len(args))
    return mem_addr, 'lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', flAllocationType=' + hex(flAllocationType) + ', flProtect=' + hex(flProtect) + ''


def VirtualFree(self, args):
    lpAddress = int(args[0], 16)
    dwSize = int(args[1], 16)
    dwFreeType = int(args[2], 16)
    clean_stack(self, len(args))
    return 0x1, 'lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', dwFreeType=' + hex(dwFreeType)


def VirtualAllocEx(self, args):
    hProcess = int(args[0], 16)
    lpAddress = int(args[1], 16)
    dwSize = int(args[2], 16)
    flAllocationType = int(args[3], 16)
    flProtect = int(args[4], 16)
    mem_addr = alloc_vmem(self, dwSize, lpAddress)
    clean_stack(self, len(args))
    return mem_addr, 'hProcess=' + hex(hProcess) + ', lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', flAllocationType=' + hex(flAllocationType) + ', flProtect=' + hex(flProtect) + ''


def WriteProcessMemory(self, args):
    hProcess = int(args[0], 16)
    lpBaseAddress = int(args[1], 16)
    lpBuffer = int(args[2], 16)
    nSize = int(args[3], 16)
    lpNumberOfBytesWritten = int(args[4], 16)
    clean_stack(self, len(args))
    return 0x1, 'hProcess=' + hex(hProcess) + ', ' + 'lpBaseAddress=' + hex(lpBaseAddress) + ', ' + 'lpBuffer=' + hex(lpBuffer) + ', ' + 'nSize=' + hex(nSize) + ', ' + 'lpNumberOfBytesWritten=' + hex(lpNumberOfBytesWritten)

def GetStdHandle(self, args):
    nStdHandle = int(args[0], 16)
    if nStdHandle == 0xfffffff6:
        handletype = 'STD_INPUT_HANDLER'
    elif nStdHandle == 0xfffffff5:
        handletype = 'STD_OUTPUT_HANDLER'
    elif nStdHandle == 0xfffffff4:
        handletype = 'STD_ERROR_HANDLER'
    else:
        handletype = hex(nStdHandle)
    handle = add_handler(self, 'STD', handletype)
    clean_stack(self, len(args))
    return handle, 'nStdHandle=' + handletype


def GetFileType(self, args):
    hFile = int(args[0], 16)
    clean_stack(self, len(args))
    val = get_handler(self, args[0])
    ret = 0x0000
    if 'STD' in val:
        ret = 0x0001
    return ret, 'hFile=' + hex(hFile)


def SetHandleCount(self, args):
    uNumber = int(args[0], 16)
    clean_stack(self, len(args))
    ret = len(self.handle) - 1
    return ret, 'uNumber=' + hex(uNumber)


def GetACP(self, args):
    ret = 28592 # 	ISO 8859-2 Central European; Central European (ISO)
    return ret, '' 


def GetModuleFileNameA(self, args):
    hModule = int(args[0], 16)
    lpFilename = int(args[1], 16)
    nSize = int(args[2], 16)
    self.uc.mem_write(lpFilename, bytes(self.drivename.encode()))
    fname = self.uc.mem_read(lpFilename, 1000).split(b'\x00')[0].decode() 
    ret = len(self.drivename)
    clean_stack(self, len(args))
    return ret, 'hModule=' + hex(hModule) + ', lpFilename="' + fname + '", nSize=' + hex(nSize)


def EnterCriticalSection(self, args):
    lpCriticalSection = int(args[0], 16)
    clean_stack(self, len(args))
    return None, 'lpCriticalSection=' + hex(lpCriticalSection)


def htons(self, args):
    hostshort = int(args[0], 16)
    clean_stack(self, len(args))
    byte_net = sock.htons(hostshort)
    return byte_net, 'hostshort=' + str(int(hostshort))


def connect(self, args):
    s = int(args[0], 16)
    name = int(args[1], 16)
    namelen = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 's=' + hex(s) + ', name=' + hex(name) + ', namelen=' + hex(namelen)


def InetPtonW(self, args):
    familly = int(args[0], 16)
    pszAddrString = int(args[1], 16)
    pAddrBuf = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 'familly=' + hex(familly) + ', pszAddrString=' + hex(pszAddrString) + ', pAddrBuf=' + hex(pAddrBuf)


def MultiByteToWideChar(self, args):
    CodePage = int(args[0], 16)
    dwFlags = int(args[1], 16)
    lpMultiByteStr = int(args[2], 16)
    cbMultiByte = int(args[3], 16)
    lpWideCharStr = int(args[4], 16)
    cchWideChar = int(args[5], 16)
    str1 = self.uc.mem_read(lpMultiByteStr, 1000).split(b'\x00')[0].decode() 
    if len(str1) > 50:
        str1 = str1[:30] + '[...]'
    clean_stack(self, len(args))
    return 0x10, 'codePage=' + hex(CodePage) + ', dwFlags=' + hex(dwFlags) + ', lpMultiByteStr="' + str1 + '", cbMultiBytes=' + hex(cbMultiByte) + ', lpWideCharStr=' + hex(lpWideCharStr) + ', cchWideChar=' + hex(cchWideChar)


def FindWindowW(self, args):
    lpClassName = int(args[0], 16)
    lpWindowName = int(args[1], 16)
    if lpWindowName == 0x0:
        name = 'DEFAULT'
    else:
        name = self.uc.mem_read(lpWindowName, 1000).split(b'\x00\x00')[0].decode() 
    clean_stack(self, len(args))
    return 0x0, 'lpClassName=' + hex(lpClassName) + ', lpWindowName="' + name + '"'


def FindWindowA(self, args):
    lpWindowName = int(args[1], 16)
    lpClassName = int(args[0], 16)
    if lpClassName == 0x0:
        classn = '0x0'
    else:
        classn = '"' + self.uc.mem_read(lpClassName, 1000).split(b'\x00')[0].decode() + '"'
    if lpWindowName == 0x0:
        name = 'DEFAULT'
    else:
        name = self.uc.mem_read(lpWindowName, 1000).split(b'\x00')[0].decode() 
    clean_stack(self, len(args))
    return 0x0, 'lpClassName=' + classn + ', lpWindowName="' + name + '"'


def GetSystemMetrics(self, args):
    nIndex = int(args[0], 16)
    clean_stack(self, len(args))
    return 0x0, 'nIndex=' + hex(nIndex) 


def GetDesktopWindow(self, args):
    handle = add_handler(self, 'Screen', 'Desktop')
    return handle, ''


def GetDC(self, args):
    hWND = int(args[0], 16)
    handle1 = get_handler(self, args[0])
    handle = add_handler(self, 'ScreenShot', 'screenshot_' + handle1)
    clean_stack(self, len(args))
    return handle, 'hWND=' + handle1


def CreateCompatibleDC(self, args):
    HDC = int(args[0], 16)
    handle1 = get_handler(self, args[0])
    handle = add_handler(self, 'Memory_ScreenShot', 'memory_screen_' + handle1[1:])
    clean_stack(self, len(args))
    return handle, 'HDC=' + handle1


def CreateCompatibleBitmap(self, args):
    hdc = int(args[0], 16)
    cx = int(args[1], 16)
    cy = int(args[2], 16)
    handle1 = get_handler(self, args[0])
    handle = add_handler(self, 'BitmapPicture', 'bitmap_' + handle1[1:])
    clean_stack(self, len(args))
    return handle, 'HDC=' + handle1 + ', cx=' + hex(cx) + ', cy=' + hex(cy)


def SelectObject(self, args):
    hdc = int(args[0], 16)
    h = int(args[1], 16)
    handle1 = get_handler(self, args[0])
    handle2 = get_handler(self, args[1])
    handle = add_handler(self, 'Object', 'obj_' + handle1[1:])
    clean_stack(self, len(args))
    return handle, 'HDC=' + handle1 + ', h=' + handle2


def BitBlt(self, args):
    hdc = int(args[0], 16)
    x = int(args[1], 16)
    y = int(args[2], 16)
    cx = int(args[3], 16)
    cy = int(args[4], 16)
    hcdSrc = int(args[5], 16)
    x1 = int(args[6], 16)
    y1 = int(args[7], 16)
    rop = int(args[8], 16)
    handle1 = get_handler(self, args[0])
    handle2 = get_handler(self, args[5])
    clean_stack(self, len(args))
    return 0x1, 'HDC=' + handle1 + ', x=' + hex(x) + ', y=' + hex(y) + ', cx=' + hex(cx) + ', cy=' + hex(cy) + ', hcdSrc=' + handle2 + ', x1=' + hex(x1) + ', y1=' + hex(y1) + ', rop=' + hex(rop)


def GetDIBits(self, args):
    hdc = int(args[0], 16)
    hbm = int(args[1], 16)
    start = int(args[2], 16)
    cLines = int(args[3], 16)
    lpvBits = int(args[4], 16)
    lpbmi = int(args[5], 16)
    usage = int(args[6], 16)
    handle1 = get_handler(self, args[0])
    handle2 = get_handler(self, args[1])
    clean_stack(self, len(args))
    return 0x0, 'HDC=' + handle1 + ', HBM=' + handle2 + ', start=' + hex(start) + ', cLines=' + hex(cLines) + ', lpvBits=' + hex(lpvBits) + ', lpbmi=' + hex(lpbmi) + ', usage=' + hex(usage)


def GetObjectA(self, args):
    h = int(args[0], 16)
    c = int(args[1], 16)
    pv = int(args[2], 16)
    handle1 = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x384, 'h=' + handle1 + ', c=' + hex(c) + ', pv=' + hex(pv) 


def GetCurrentHwProfileA(self, args):
    lpHwProfileInfo = int(args[0], 16)
    clean_stack(self, len(args))
    return 0x1, 'lpHwProfileInfo=' + hex(lpHwProfileInfo) 


def GetUserNameA(self, args):
    lpBuffer = int(args[0], 16)
    pcbBuffer = int(args[1], 16)
    ptr = self.uc.mem_read(lpBuffer, 4)
    if int(ptr.hex()) == 0:
        self.uc.mem_write(lpBuffer, bytes(self.username.encode()))
    else:
        self.uc.mem_write(lpBuffer, bytes(self.username.encode()))
    clean_stack(self, len(args))
    return len(self.username), 'lpBuffer="' + hex(lpBuffer) + ', pcbBuffer=' + hex(pcbBuffer)


def gethostname(self, args):
    name = int(args[0], 16)
    namelen = int(args[0], 16)
    ptr = self.uc.mem_read(name, 4)
    self.uc.mem_write(name, bytes(self.username.encode()))
    clean_stack(self, len(args))
    return 0x0, 'name=' + hex(name) + ', namelen=' + hex(namelen)


def FindFirstFileA(self, args):
    lpFileName = int(args[0], 16)
    lpFindFileData = int(args[1], 16)
    fname = self.uc.mem_read(lpFileName, 1000).split(b'\x00')[0].decode() 
    handle = add_handler(self, 'search_file', fname)
    clean_stack(self, len(args))
    return handle, 'lpFileName="' + fname + '", lpFindFileData=' + hex(lpFindFileData)


def OutputDebugStringA(self, args):
    lpOutputString = int(args[0], 16)
    str1 = self.uc.mem_read(lpOutputString, 1000).split(b'\x00')[0].decode() 
    clean_stack(self, len(args))
    return None, 'lpOutputString="' + str1 + '"'


def OpenProcessToken(self, args):
    ProcessHandle = int(args[0], 16)
    DesiredAccess = int(args[1], 16)
    TokenHandle = int(args[2], 16)
    handle = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x1, 'ProcessHandle=' + handle + ', ' + 'DesiredAccess=' + hex(DesiredAccess) + ', ' + 'TokenHandle=' + hex(TokenHandle)


def GetCurrentProcess(self, args):
    handle = add_handler(self, 'file', self.drivename)
    return handle, ''


def CreateProcessA(self, args):
    lpApplicationName = int(args[0], 16)
    lpCommandLine = int(args[1], 16)
    lpProcessAttributes = int(args[2], 16)
    lpThreadAttributes = int(args[3], 16)
    bInheritHandles = int(args[4], 16)
    lpCreationFlags = int(args[5], 16)
    lpEnvironment = int(args[6], 16)
    lpCurrentDirectory = int(args[7], 16)
    lpStartupInfo = int(args[8], 16)
    lpProcessInformation = int(args[9], 16)
    if lpApplicationName != 0x0:
        name = '"' + self.uc.mem_read(lpApplicationName, 1000).split(b'\x00')[0].decode()  + '"'
    else:
        name = '0x0'
    if lpCommandLine != 0x0:
        cmd = '"' + self.uc.mem_read(lpCommandLine, 1000).split(b'\x00')[0].decode()  + '"'
    else:
        cmd = '0x0'
    if lpCreationFlags == 0x01000000:
        flag = 'CREATE_BREAKAWAY_FROM_JOB'
    elif lpCreationFlags == 0x04000000:
        flag = 'CREATE_DEFAULT_ERROR_MODE'
    elif lpCreationFlags == 0x00000010:
        flag = 'CREATE_NEW_CONSOLE'
    elif lpCreationFlags == 0x00000200:
        flag = 'CREATE_NEW_PROCESS_GROUP'
    elif lpCreationFlags == 0x08000000:
        flag = 'CREATE_NO_WINDOW'
    elif lpCreationFlags == 0x00040000:
        flag = 'CREATE_PROTECTED_PROCESS'
    elif lpCreationFlags == 0x02000000:
        flag = 'CREATE_PRESERVE_CODE_AUTHZ_LEVEL'
    elif lpCreationFlags == 0x00400000: 
        flag = 'CREATE_SECURE_PROCESS'
    elif lpCreationFlags == 0x00000800:
        flag = 'CREATE_SEPARATE_WOW_VDM'
    elif lpCreationFlags == 0x00001000:
        flag = 'CREATE_SHARED_WOW_VDM'
    elif lpCreationFlags == 0x00000004:
        flag = 'CREATE_SUSPENDED'
    elif lpCreationFlags == 0x00000400:
        flag = 'CREATE_UNICODE_ENVIRONMENT'
    elif lpCreationFlags == 0x00000002:
        flag = 'DEBUG_ONLY_THIS_PROCESS'
    elif lpCreationFlags == 0x00000001:
        flag = 'DEBUG_PROCESS'
    elif lpCreationFlags == 0x00000008:
        flag = 'DETACHED_PROCESS'
    elif lpCreationFlags == 0x00080000:
        flag = 'EXTENDED_STARTUPINFO_PRESENT'
    elif lpCreationFlags == 0x00010000:
        flag = 'INHERIT_PARENT_AFFINITY'
    else:
        flag = 'CREATE_UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'lpApplicationName=' + name + ', ' + 'lpCommandLine=' + cmd + ', ' + 'lpProcessAttributes=' + hex(lpProcessAttributes) + ', ' + 'lpThreadAttributes=' + hex(lpThreadAttributes) + ', ' + 'bInheritHandles=' + hex(bInheritHandles) + ', ' + 'dwCreationFlags=' +flag + ', ' + 'lpEnvironment=' + hex(lpEnvironment) + ', ' + 'lpCurrentDirectory=' + hex(lpCurrentDirectory) + ', ' + 'lpStartupInfo=' + hex(lpStartupInfo) + ', ' + 'lpProcessInformation=' + hex(lpProcessInformation)


def ResumeThread(self, args):
    hThread = int(args[0], 16)
    clean_stack(self, len(args))
    return 0x1, 'hThread=' + hex(hThread)


def GetThreadContext(self, args):
    hThread = int(args[0], 16)
    lpContext = int(args[1], 16)
    clean_stack(self, len(args))
    return 0x1, 'hThread=' + hex(hThread) + ', ' + 'lpContext=' + hex(lpContext)


def SetThreadContext(self, args):
    hThread = int(args[0], 16)
    lpContext = int(args[1], 16)
    clean_stack(self, len(args))
    return 0x1, 'hThread=' + hex(hThread) + ', ' + 'lpContext=' + hex(lpContext)


def GetTokenInformation(self, args):
    TokenHandle = int(args[0], 16)
    TokenInformationClass = int(args[1], 16)
    TokenInformation = int(args[2], 16)
    TokenInformationLength = int(args[3], 16)
    ReturnLength = int(args[4], 16)
    clean_stack(self, len(args))
    return 0x0, 'TokenHandle=' + hex(TokenHandle) + ', ' + 'TokenInformationClass=' + hex(TokenInformationClass) + ', ' + 'TokenInformation=' + hex(TokenInformation) + ', ' + 'TokenInformationLength=' + hex(TokenInformationLength) + ', ' + 'ReturnLength=' + hex(ReturnLength)


def Sleep(self, args):
    dwMilliseconds= int(args[0], 16)
    clean_stack(self, len(args))
    return None, 'dwMilliseconds=' + hex(dwMilliseconds)


def MessageBoxW(self, args):
    hWnd = int(args[0], 16)
    lpText = int(args[1], 16)
    lpCaption = int(args[2], 16)
    uType = int(args[3], 16)
    str1 = self.uc.mem_read(lpText, 1000).split(b'\x00\x00')[0].decode() 
    str2 = self.uc.mem_read(lpCaption, 1000).split(b'\x00\x00')[0].decode() 
    clean_stack(self, len(args))
    return 11, 'hWnd=' + hex(hWnd) + ', ' + 'lpText="' + str1 + '", ' + 'lpCaption="' + str2 + '", ' + 'uType=' + hex(uType)


def CreateFileA(self, args):
    lpFileName = int(args[0], 16)
    dwDesiredAccess = int(args[1], 16)
    dwShareMode = int(args[2], 16)
    lpSecurityAttributes = int(args[3], 16)
    dwCreationDisposition = int(args[4], 16)
    dwFlagsAndAttributes = int(args[5], 16)
    hTemplateFile = int(args[6], 16)
    
    fname = self.uc.mem_read(lpFileName, 1000).split(b'\x00')[0].decode() 

    if dwShareMode == 0:
        share = 'BLOCK_MODE'
    elif dwShareMode == 1:
        share = 'FILE_SHARE_READ'
    elif dwShareMode == 2:
        share = 'FILE_SHARE_WRITE'
    elif dwShareMode == 4:
        share = 'FILE_SHARE_DELETE'

    if dwCreationDisposition == 1:
        creation = 'CREATE_NEW'
    if dwCreationDisposition == 2:
        creation = 'CREATE_ALWAYS'
    if dwCreationDisposition == 3:
        creation = 'OPEN_EXISTING'
    if dwCreationDisposition == 4:
        creation = 'OPEN_ALWAYS'
    if dwCreationDisposition == 5:
        creation = 'TRUNCATE_EXISTING'

    clean_stack(self, len(args))
    ret = add_handler(self, 'file', fname)
    #ret = 0xffffffff #File not found
    return ret, 'lpFileName="' + fname + '", ' + 'dwDesiredAccess=' + hex(dwDesiredAccess) + ', ' + 'dwShareMode=' + share + ', ' + 'lpSecurityAttributes=' + hex(lpSecurityAttributes) + ', ' + 'dwCreationDisposition=' + creation + ', ' + 'dwFlagsAndAttributes=' + hex(dwFlagsAndAttributes) + ', ' + 'hTemplateFile=' + hex(hTemplateFile)


def DeviceIoControl(self, args):
    hDevice = int(args[0], 16)
    dwIoControlCode = int(args[1], 16)
    lpInBuffer = int(args[2], 16)
    nInBufferSize = int(args[3], 16)
    lpOutBuffer = int(args[4], 16)
    nOutBufferSize = int(args[5], 16)
    lpBytesReturned = int(args[6], 16)
    lpOverlapped = int(args[7], 16)
    handle = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x1, 'hDevice="' + handle + '", ' + 'dwIoControlCode=' + hex(dwIoControlCode) + ', ' + 'lpInBuffer=' + hex(lpInBuffer) + ', ' + 'nInBufferSize=' + hex(nInBufferSize) + ', ' + 'lpOutBuffer=' + hex(lpOutBuffer) + ', ' + 'nOutBufferSize=' + hex(nOutBufferSize) + ', ' + 'lpBytesReturned=' + hex(lpBytesReturned) + ', lpOverlapped=' + hex(lpOverlapped)


def OleInitialize(self, args):
    pvReserved = int(args[0], 16)
    clean_stack(self, len(args))
    return 0x0, 'pvReserved=' + hex(pvReserved)


def CoCreateInstance(self, args):
    rclsid = int(args[0], 16)
    pUnkOuter = int(args[1], 16)
    dwClsContext = int(args[2], 16)
    riid = int(args[3], 16)
    ppv = int(args[4], 16)
    #TODO: extract CLSID
    clean_stack(self, len(args))
    return 0x0, 'rclsid=' + hex(rclsid) + ', pUnkOuter=' + hex(pUnkOuter) + ', dwClsContext=' + hex(dwClsContext) + ', riid=' + hex(riid) + ', ppv=' + hex(ppv)


def SysAllocString(self, args):
    psz = int(args[0], 16)
    name = self.uc.mem_read(psz, 1000).split(b'\x00\x00')[0].decode()
    clean_stack(self, len(args))
    return psz, 'psz="' + name + '"'


def CloseHandle(self, args):
    hObject = int(args[0], 16)
    val = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x2, 'hObject=' + val


def CloseServiceHandle(self, args):
    hSCObject = int(args[0], 16)
    val = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x2, 'hSCObject=' + val


def WSAStartup(self, args):
    wVersionRequired = int(args[0], 16)
    lpWSAData = int(args[1], 16)
    clean_stack(self, len(args))
    return 0x0, 'wVersionRequired=' + hex(wVersionRequired) + ', lpWSAData=' + hex(lpWSAData)


def InternetOpenA(self, args):
    lpszAgent = int(args[0], 16)
    dwAccessType = int(args[1], 16)
    lpszProxy = int(args[2], 16)
    lpszProxyBypass = int(args[3], 16)
    dwFlags = int(args[4], 16)
    agent = self.uc.mem_read(lpszAgent, 1000).split(b'\x00')[0].decode()
    if lpszProxy != 0x0:
        proxy = self.uc.mem_read(lpszProxy, 1000).split(b'\x00')[0].decode()
    else:
        proxy = '0x0'
    if lpszProxyBypass != 0x0:
        bypass = self.uc.mem_read(lpszProxyBypass, 1000).split(b'\x00')[0].decode()
    else:
        bypass = '0x0'
    ret = add_handler(self, 'Internet', agent)
    clean_stack(self, len(args))
    return ret, 'lpszAgent=' + agent + ', dwAccessType=' + hex(dwAccessType) + ', lpszProxy=' + proxy + ', lpszProxyBypass=' + bypass + ', dwFlags=' + hex(dwFlags)
    

def InternetOpenUrlA(self, args):
    hInternet = int(args[0], 16)
    lpszUrl = int(args[1], 16)
    lpszHeaders = int(args[2], 16)
    dwHeadersLength = int(args[3], 16)
    dwFlags = int(args[4], 16)
    dwContext = int(args[5], 16)
    val = get_handler(self, args[0])
    url = self.uc.mem_read(lpszUrl, 1000).split(b'\x00')[0].decode()
    if lpszHeaders != 0x0:
        header = self.uc.mem_read(lpszHeader, 1000).split(b'\x00')[0].decode()
    else:
        header = '0x0'
    ret = add_handler(self, 'URL', url)
    clean_stack(self, len(args))
    return ret, 'hInternet=' + val + ', lpszUrl=' + url + ', lpszHeader=' + header + ', dwHeadersLength=' + hex(dwHeadersLength) + ', dwFlags=' + hex(dwFlags) + ', dwContext=' + hex(dwContext)


def URLDownloadToCacheFileA(self, args):
    lpUnkCaller = int(args[0], 16)
    szUrl = int(args[1], 16)
    szFileName = int(args[2], 16)
    cchFileName = int(args[3], 16)
    dwReserved = int(args[4], 16)
    pBSC = int(args[5], 16)
    url = self.uc.mem_read(szUrl, 1000).split(b'\x00')[0].decode()
    filename = self.uc.mem_read(szFileName, 1000).split(b'\x00')[0].decode()
    clean_stack(self, len(args))
    return 0x0, 'lpUnkCaller=' + hex(lpUnkCaller) + ', szUrl=' + url + ', szFileName=' + filename + ', cchFileName=' + hex(cchFileName) + ', dwReserved=' + hex(dwReserved) + ', pBSC=' + hex(pBSC)


def URLDownloadToFileA(self, args):
    pCaller = int(args[0], 16)
    szUrl = int(args[1], 16)
    szFileName = int(args[2], 16)
    dwReserved = int(args[3], 16)
    lpfnCB = int(args[4], 16)
    url = self.uc.mem_read(szUrl, 1000).split(b'\x00')[0].decode()
    filename = self.uc.mem_read(szFileName, 1000).split(b'\x00')[0].decode()
    clean_stack(self, len(args))
    return 0x0, 'pCaller=' + hex(pCaller) + ', szUrl=' + url + ', szFileName=' + filename + ', dwReserved=' + hex(dwReserved) + ', lpfnCB=' + hex(lpfnCB)


def ExitProcess(self, args):
    uExitCode = int(args[0], 16)
    return 0xdeadbabe, 'EXIT'


def exit(self, args):
    uExitCode = int(args[0], 16)
    return 0xdeadbabe, 'EXIT'


def _exit(self, args):
    uExitCode = int(args[0], 16)
    return 0xdeadbabe, 'EXIT'

