# Syscall functions for the Windows Malware Emulator

default_ret_code = 0x0

# Utility functions
def clean_stack(self, num):
    for x in range(num):
        self.decstack()
    return

def add_handler(self, handle_type, handler_value):
    higher_val = [(k, self.handle[k]) for k in sorted(self.handle)][-1][0]
    last_value = int(higher_val, 16) + 1
    self.handle[hex(last_value)] = [handler_value, handle_type]
    return last_value

def get_handler(self, handle_addr):
    hval = self.handle[handle_addr][0]
    htype = self.handle[handle_addr][1]
    return 'h' + hval

def add_syscall(self, name):
    # Add an entry in the IAT_hook structure
    higher_val = list({k: self.IAT_hook[k] for k in sorted(self.IAT_hook, key=self.IAT_hook.get)}.values())[-1]
    new_value = int(higher_val, 16) + 4
    self.IAT_hook[name] = '0x%08x' % new_value
    # Add an entry in the fake Import Address Table
    higher_val = [(k, self.IAT['dynamic_import'][k]) for k in sorted(self.IAT['dynamic_import'])]
    new_addr = '0x%08x' % (int(higher_val[-1][0], 16) + 4)
    self.IAT['dynamic_import'][new_addr] = name
    # Add an entry in the non-ordered Import Address Table structure
    self.raw_IAT[new_addr] = name
    return hex(new_value)

def __set_app_type(self, args):
    at = int(args[0], 16)
    if at == 0:
        app_type = 'at=UNKNWON_APP'
    elif at == 1:
        app_type = 'at=CONSOLE_APP'
    elif at == 2:
        app_type = 'at=GUI_APP'
    else:
        app_type = 'at=INVALID_VALUE'
    ret_args = [app_type]
    return default_ret_code, ret_args

def GetStartupInfoA(self, args):
    lpStartupInfo = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpStartupInfo=' + hex(lpStartupInfo)

def GetModuleHandleA(self, args):
    lpModuleName = int(args[0], 16)
    clean_stack(self, len(args))
    return default_ret_code, 'lpModuleName=' + hex(lpModuleName)

def GetSystemTimeAsFileTime(self, args):
    timestruct = int(args[0], 16)
    ret_code = None
    return ret_code, 'lpSystemTimeAsFileTime=' + hex(timestruct)

def GetCurrentThreadId(self, args):
    tid = self.thread_ID
    return tid, ''

def GetCurrentProcessId(self, args):
    pid = self.process_ID
    return pid, ''

def IsProcessorFeaturePresent(self, args):
    feature = int(args[0], 16)
    if feature == 25:
        feature_type = 'PF_ARM_64BITS_LOADSTORE_ATOMIC'
    elif feature == 24:
        feature_type = 'PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE'
    elif feature == 26:
        feature_type = 'PF_ARM_EXTERNAL_CACHE_AVAILABLE'
    elif feature == 27:
        feature_type = 'PF_ARM_FMAC_INSTRUCTION_AVAILABLE'
    elif feature == 18:
        feature_type = 'PF_ARM_VFP_32_REGISTERS_AVAILABLE'
    elif feature == 7:
        feature_type = 'PF_3DNOW_INSTRUCTION_AVAILABLE'
    elif feature == 16:
        feature_type = 'PF_CHANNELS_ENABLED'
    elif feature == 2:
        feature_type = 'PF_COMPARE_EXCHANGE_DOUBLE'
    elif feature == 14:
        feature_type = 'PF_COMPARE_EXCHANGE128'
    else:
        feature_type = 'UNKNOWN'
    return 0x1, 'ProcessorFeature=' + feature_type

def GetProcAddress(self, args):
    hModule = get_handler(self, args[0])
    lpProcName_addr = int(args[1], 16)
    lpProcName = self.uc.mem_read(lpProcName_addr, 1000).split(b'\x00')[0].decode() 
    func_addr = add_syscall(self, lpProcName)
    clean_stack(self, len(args))
    self.dynamics.append([func_addr, lpProcName])
    return int(func_addr, 16), 'hModule=' + hModule + ', lpProcName="' + lpProcName + '"'

def LoadLibraryA(self, args):
    addr = int(args[0], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName=' + lpLibFileName

def CreateMutexA(self, args):
    lpMutexAttributes = int(args[0], 16)
    bInitialOwner = int(args[1], 16)
    lpName_addr = int(args[2], 16)
    lpName = self.uc.mem_read(lpName_addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'mutex', lpName)
    clean_stack(self, len(args))
    return handle, 'lpMutexAttributes=' + hex(lpMutexAttributes) + ', bInitialOwner=' + hex(bInitialOwner) + ', lpName="' + lpName + '"'
