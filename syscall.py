# Syscall functions for the Windows Malware Emulator
import socket as sock

default_ret_code = 0x0
PAGE_SIZE = 0x1000
ALIGNED_PAGE = lambda x: (x + PAGE_SIZE - 1) & ~(PAGE_SIZE-1)
HEAP_MIN = 0x60000000
HEAP_MAX = 0xFFFFFFFF

# Utility functions
def clean_stack(self, num):
    for x in range(num):
        self.decstack()
    return

def add_handler(self, handle_type, handler_value):
    higher_val = [(k, self.handle[k]) for k in sorted(self.handle)][-1][0]
    last_value = int(higher_val, 16) + 1
    self.handle[hex(last_value)] = [handler_value, handle_type]
    return last_value


def get_handler(self, handle_addr):
    hval = self.handle[handle_addr][0]
    htype = self.handle[handle_addr][1]
    return 'h' + hval


def add_syscall(self, name):
    # Add an entry in the IAT_hook structure
    higher_val = list({k: self.IAT_hook[k] for k in sorted(self.IAT_hook, key=self.IAT_hook.get)}.values())[-1]
    new_value = int(higher_val, 16) + 4
    self.IAT_hook[name] = '0x%08x' % new_value
    # Add an entry in the fake Import Address Table
    higher_val = [(k, self.IAT['dynamic_import'][k]) for k in sorted(self.IAT['dynamic_import'])]
    new_addr = '0x%08x' % (int(higher_val[-1][0], 16) + 4)
    self.IAT['dynamic_import'][new_addr] = name
    # Add an entry in the non-ordered Import Address Table structure
    self.raw_IAT[new_addr] = name
    return hex(new_value)

class Heap():
    def __init__(self, address, size, data_size):
        self.size = size
        self.address = address
        self.data_size = data_size
        self.data_address = address + PAGE_SIZE

        def is_chunk(self, address, size):
            if address >= self.data_address and ((address + size) <= (self.data_address + self.data_size)):
                return True
            else:
                return False

def alloc_heap(self, size):
    total_chunk_size = PAGE_SIZE + ALIGNED_PAGE(size) + PAGE_SIZE
    chunk = None
    for address in range(HEAP_MIN, HEAP_MAX, PAGE_SIZE):
        try:
            self.uc.mem_map(address, total_chunk_size)
            chunk = Heap(address, total_chunk_size, size)
            if self.debug:
                print('[!] Allocating a ' + hex(chunk.data_size) + ' bytes chunk at address ' + hex(chunk.data_address))
            break
        except:
            continue
    if chunk == None:
        return False
    self.chunks.append(chunk)
    return chunk.data_address

def __set_app_type(self, args):
    at = int(args[0], 16)
    if at == 0:
        app_type = 'at=UNKNWON_APP'
    elif at == 1:
        app_type = 'at=CONSOLE_APP'
    elif at == 2:
        app_type = 'at=GUI_APP'
    else:
        app_type = 'at=INVALID_VALUE'
    ret_args = [app_type]
    clean_stack(self, len(args))
    return default_ret_code, ret_args


def GetStartupInfoA(self, args):
    lpStartupInfo = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpStartupInfo=' + hex(lpStartupInfo)


def GetModuleHandleA(self, args):
    lpModuleName = int(args[0], 16)
    if lpModuleName == 0x0:
        lpModuleName = '"' + self.drivename + '"'
        ret = add_handler(self, 'module', self.drivename)
    else:
        ret = add_handler(self, 'module', lpModuleName)
        lpModuleName = str(hex(lpModuleName))
    clean_stack(self, len(args))
    return ret, 'lpModuleName=' + lpModuleName


def OpenSCManagerA(self, args):
    lpMachineName = int(args[0], 16)
    lpDatabaseName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    if lpMachineName == 0x0:
        lpMachineName = 'LOCAL_COMPUTER'
    else:
        lpMachineName = str(hex(lpMachineName))
    if lpDatabaseName == 0x0:
        lpDatabaseName = 'SERVICE_ACTIVE_DATABASE'
    else:
        lpDatabaseName = str(hex(lpMachineName))
    ret = add_handler(self, 'service_control_manager', lpDatabaseName)
    clean_stack(self, len(args))
    return ret, 'lpMachineName=' + lpMachineName + ', lpDatabaseName=' + lpDatabaseName + ', dwDesiredAccess=' + hex(dwDesiredAccess)


def OpenServiceA(self, args):
    hSCManager = int(args[0], 16)
    lpServiceName = int(args[1], 16)
    dwDesiredAccess = int(args[2], 16)
    service = self.uc.mem_read(lpServiceName, 1000).split(b'\x00')[0].decode()
    ret = add_handler(self, 'service', service)
    clean_stack(self, len(args))
    return ret, 'hSCManager=' + hex(hSCManager) + ', lpServiceName="' + service + '", dwDesiredAccess=' + hex(dwDesiredAccess)
    

def CreateServiceA(self, args):
    hSCManager = int(args[0], 16)
    lpServiceName = int(args[1], 16)
    lpDisplayName = int(args[2], 16)
    dwDesiredAccess = int(args[3], 16)
    dwServiceType = int(args[4], 16)
    dwStartType = int(args[5], 16)
    dwErrorControl = int(args[6], 16)
    lpBinaryPathName = int(args[7], 16)
    lpLoadOrderGroup = int(args[8], 16)
    lpdwTagId = int(args[9], 16)
    lpDependencies = int(args[10], 16)
    lpServiceStartName = int(args[11], 16)
    lpPassword = int(args[12], 16)
    handle = get_handler(self, args[0])
    serviceName = self.uc.mem_read(lpServiceName, 1000).split(b'\x00')[0].decode()
    displayName = self.uc.mem_read(lpDisplayName, 1000).split(b'\x00')[0].decode()
    binPath = self.uc.mem_read(lpBinaryPathName, 1000).split(b'\x00')[0].decode()
    if dwServiceType == 0x4:
        serviceType = 'SERVICE_ADAPTER'
    elif dwServiceType == 0x2:
        serviceType = 'SERVICE_FILE_SYSTEM_DRIVER'
    elif dwServiceType == 0x1:
        serviceType = 'SERVICE_KERNEL_DRIVER'
    elif dwServiceType == 0x8:
        serviceType = 'SERVICE_RECONIZER_DRIVER'
    elif dwServiceType == 0x10:
        serviceType = 'SERVICE_WIN32_OWN_PROCESS'
    elif dwServiceType == 0x20:
        serviceType = 'SERVICE_WIN32_SHARE_PROCESS'
    elif dwServiceType == 0x50:
        serviceType = 'SERVICE_USER_OWN_PROCESS'
    elif dwServiceType == 0x60:
        serviceType = 'SERVICE_USER_SHARE_PROCESS'
    else:
        serviceType = 'SERVICE_UNKNWON'
    if dwStartType == 0x2:
        startType = 'SERVICE_AUTO_START'
    elif dwStartType == 0x0:
        startType = 'SERVICE_BOOT_STRAT'
    elif dwStartType == 0x3:
        startType = 'SERVICE_DEMAND_STRAT'
    elif dwStartType == 0x4:
        startType = 'SERVICE_DISABLED'
    elif dwStartType == 0x1:
        startType = 'SERVICE_SYSTEM_START'
    else:
        startType = 'SERVICE_UNKNOWN'
    if dwErrorControl == 0x3:
        errorControl = 'SERVICE_ERROR_CRITICAL'
    elif dwErrorControl == 0x0:
        errorControl = 'SERVICE_ERROR_IGNORE'
    elif dwErrorControl == 0x1:
        errorControl = 'SERVICE_ERROR_NORMAL'
    elif dwErrorControl == 0x2:
        errorControl = 'SERVICE_ERROR_SEVERE'
    else:
        errorControl = 'SERVICE_ERROR_UNKNOWN'
    clean_stack(self, len(args))
    ret = add_handler(self, 'service', serviceName)
    return ret, 'hSCManager=' + handle + ', lpServiceName="' + serviceName + '", lpDisplayName="' + displayName + '", dwDesiredAccess=' + hex(dwDesiredAccess) + ', dwServiceType=' + serviceType + ', dwStartType=' + startType + ', dwErrorControl=' + errorControl + ', lpBinaryPathName="' + binPath + '", lpLoadOrderGroup=' + hex(lpLoadOrderGroup) + ', lpdwTagId=' + hex(lpdwTagId) + ', lpDependencies=' + hex(lpDependencies) + ', lpServiceStartName=' + hex(lpServiceStartName) + ', lpPassword=' + hex(lpPassword)


def FindResourceA(self, args):
    hModule = int(args[0], 16)
    lpName = int(args[1], 16)
    lpType = int(args[2], 16)
    if hModule == 0x0:
        handle = self.shortname
    else:
        handle = get_handler(self, args[0])
    ret = add_handler(self, 'resource', hex(lpName))
    clean_stack(self, len(args))
    return ret, 'hModule=' + handle + ', ' + 'lpName=' + hex(lpName) + ', ' + 'lpType=' + hex(lpType)


def StartServiceA(self, args):
    hService = int(args[0], 16)
    dwNumServiceArgs = int(args[1], 16)
    lpServiceArgVector = int(args[2], 16)
    handle = get_handler(self, args[0])
    if lpServiceArgVector == 0x0:
        vector = str(hex(lpServiceArgVector))
    else:
        vector = self.uc.mem_read(lpServiceArgVector, 1000).split(b'\x00')[0].decode()
    clean_stack(self, len(args))
    return 0x1, 'hService=' + handle + ', dwNumServiceArgs=' + hex(dwNumServiceArgs) + ', lpServiceArgVector=' + vector


def ControlService(self, args):
    hService = int(args[0], 16)
    dwControl = int(args[1], 16)
    lpServiceStatus = int(args[2], 16)
    handle = get_handler(self, args[0])
    if dwControl == 0x3:
        control = 'SERVICE_CONTROL_CONTINUE'
    elif dwControl == 0x4:
        control = 'SERVICE_CONTROL_INTERROGATE'
    elif dwControl == 0x7:
        control = 'SERVICE_CONTROL_NETBINDADD'
    elif dwControl == 0xA:
        control = 'SERVICE_CONTROL_NETBINDDISABLE'
    elif dwControl == 0x9:
        control = 'SERVICE_CONTROL_NETBINDENABLE'
    elif dwControl == 0x8:
        control = 'SERVICE_CONTROL_NETBINDREMOVE'
    elif dwControl == 0x6:
        control = 'SERVICE_CONTROL_PARAMCHANGE'
    elif dwControl == 0x2:
        control = 'SERVICE_CONTROL_PAUSE'
    elif dwControl == 0x1:
        control = 'SERVICE_CONTROL_STOP'
    else:
        control = 'SERVICE_CONTROL_UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'hService=' + handle + ', ' + 'dwControl=' + control + ', ' + 'lpServiceStatus=' + hex(lpServiceStatus)


def GetSystemTimeAsFileTime(self, args):
    timestruct = int(args[0], 16)
    ret_code = None
    clean_stack(self, len(args))
    return ret_code, 'lpSystemTimeAsFileTime=' + hex(timestruct)


def GetCurrentThreadId(self, args):
    tid = self.thread_ID
    return tid, ''


def GetCurrentProcessId(self, args):
    pid = self.process_ID
    return pid, ''


def IsProcessorFeaturePresent(self, args):
    feature = int(args[0], 16)
    if feature == 25:
        feature_type = 'PF_ARM_64BITS_LOADSTORE_ATOMIC'
    elif feature == 24:
        feature_type = 'PF_ARM_DIVIDE_INSTRUCTION_AVAILABLE'
    elif feature == 26:
        feature_type = 'PF_ARM_EXTERNAL_CACHE_AVAILABLE'
    elif feature == 27:
        feature_type = 'PF_ARM_FMAC_INSTRUCTION_AVAILABLE'
    elif feature == 18:
        feature_type = 'PF_ARM_VFP_32_REGISTERS_AVAILABLE'
    elif feature == 7:
        feature_type = 'PF_3DNOW_INSTRUCTION_AVAILABLE'
    elif feature == 16:
        feature_type = 'PF_CHANNELS_ENABLED'
    elif feature == 2:
        feature_type = 'PF_COMPARE_EXCHANGE_DOUBLE'
    elif feature == 14:
        feature_type = 'PF_COMPARE_EXCHANGE128'
    else:
        feature_type = 'UNKNOWN'
    clean_stack(self, len(args))
    return 0x1, 'ProcessorFeature=' + feature_type


def GetProcAddress(self, args):
    hModule = get_handler(self, args[0])
    lpProcName_addr = int(args[1], 16)
    lpProcName = self.uc.mem_read(lpProcName_addr, 1000).split(b'\x00')[0].decode() 
    func_addr = add_syscall(self, lpProcName)
    clean_stack(self, len(args))
    self.dynamics.append([func_addr, lpProcName])
    return int(func_addr, 16), 'hModule=' + hModule + ', lpProcName="' + lpProcName + '"'


def LoadLibraryA(self, args):
    addr = int(args[0], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName=' + lpLibFileName


def LoadLibraryExW(self, args):
    addr = int(args[0], 16)
    hFile = int(args[1], 16)
    flags = int(args[2], 16)
    lpLibFileName = self.uc.mem_read(addr, 1000).split(b'\x00\x00\x00\x00')[0].decode() # Should be enought to get the shared library name
    if flags == 0x800:
        dwFlags = 'LOAD_LIBRARY_SEARCH_SYSTEM32'
    elif flags == 0x1:
        dwFlags = 'DONT_RESOLVE_DLL_REFERENCES'
    elif flags == 0x10:
        dwFlags = 'LOAD_IGNORE_CODE_AUTHZ_LEVEL'
    elif flags == 0x2:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE'
    elif flags == 0x40:
        dwFlags = 'LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE'
    elif flags == 0x20:
        dwFlags = 'LOAD_LIBRARY_AS_IMAGE_RESOURCE'
    elif flags == 0x200:
        dwFlags = 'LOAD_LIBRARY_SEARCH_APPLICATION_DIR'
    elif flags == 0x1000:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DEFAULT_DIRS'
    elif flags == 0x100:
        dwFlags = 'LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR'
    elif flags == 0x400:
        dwFlags = 'LOAD_LIBRARY_SEARCH_USER_DIRS'
    elif flags == 0x8:
        dwFlags = 'LOAD_WITH_ALTERED_SEARCH_PATH'
    elif flags == 0x80:
        dwFlags = 'LOAD_LIBRARY_REQUIRE_SIGNED_TARGET'
    elif flags == 0x2000:
        dwFlags = 'LOAD_LIBRARY_SAFE_CURRENT_DIRS'
    else:
        dwFlags = 'UNKNWON'
    handle = add_handler(self, 'module', lpLibFileName)
    clean_stack(self, len(args))
    return handle, 'lpLibFileName="' + lpLibFileName + '", hFile=' + hex(hFile) + ', dwFlags=' + dwFlags

def CreateMutexA(self, args):
    lpMutexAttributes = int(args[0], 16)
    bInitialOwner = int(args[1], 16)
    lpName_addr = int(args[2], 16)
    lpName = self.uc.mem_read(lpName_addr, 1000).split(b'\x00')[0].decode() # Should be enought to get the shared library name
    handle = add_handler(self, 'mutex', lpName)
    clean_stack(self, len(args))
    return handle, 'lpMutexAttributes=' + hex(lpMutexAttributes) + ', bInitialOwner=' + hex(bInitialOwner) + ', lpName="' + lpName + '"'


def HeapCreate(self, args):
    flOptions = int(args[0], 16)
    dwInitialSize = int(args[1], 16)
    dwMaximumSize = int(args[2], 16)
    # Todo: Allocate real memory
    addr = 0x1234
    handle = add_handler(self, 'heap', addr)
    clean_stack(self, len(args))
    return handle, 'flOptions=' + hex(flOptions) + ', dwInitialSize=' + hex(dwInitialSize) + ', dwMaximumSize=' + hex(dwMaximumSize) + ''


def HeapAlloc(self, args):
    hHeap = int(args[0], 16)
    dwFlags = int(args[1], 16)
    dwBytes = int(args[2], 16)
    chunk_ptr = alloc_heap(self, dwBytes)
    clean_stack(self, len(args))
    return chunk_ptr, 'hHeap=' + hex(hHeap) + ', dwFlags=' + hex(dwFlags) + ', dwBytes=' + hex(dwBytes)


def mem_allocate(address, size):
    #print(address, size)
    return


def VirtualAlloc(self, args):
    lpAddress = int(args[0], 16)
    dwSize = int(args[1], 16)
    flAllocationType = int(args[2], 16)
    flProtect = int(args[3], 16)

    # Todo: Allocate real memory
    mem_obj = mem_allocate(lpAddress, dwSize)

    addr = 0x4321
    clean_stack(self, len(args))
    return addr, 'lpAddress=' + hex(lpAddress) + ', dwSize=' + hex(dwSize) + ', flAllocationType=' + hex(flAllocationType) + ', flProtect=' + hex(flProtect) + ''


def GetStdHandle(self, args):
    nStdHandle = int(args[0], 16)
    if nStdHandle == 0xfffffff6:
        handletype = 'STD_INPUT_HANDLER'
    elif nStdHandle == 0xfffffff5:
        handletype = 'STD_OUTPUT_HANDLER'
    elif nStdHandle == 0xfffffff4:
        handletype = 'STD_ERROR_HANDLER'
    else:
        handletype = hex(nStdHandle)
    handle = add_handler(self, 'STD', handletype)
    clean_stack(self, len(args))
    return handle, 'nStdHandle=' + handletype


def GetFileType(self, args):
    hFile = int(args[0], 16)
    clean_stack(self, len(args))
    val = get_handler(self, args[0])
    ret = 0x0000
    if 'STD' in val:
        ret = 0x0001
    return ret, 'hFile=' + hex(hFile)


def SetHandleCount(self, args):
    uNumber = int(args[0], 16)
    clean_stack(self, len(args))
    ret = len(self.handle) - 1
    return ret, 'uNumber=' + hex(uNumber)


def GetACP(self, args):
    ret = 28592 # 	ISO 8859-2 Central European; Central European (ISO)
    return ret, '' 


def GetModuleFileNameA(self, args):
    hModule = int(args[0], 16)
    lpFilename = int(args[1], 16)
    nSize = int(args[2], 16)
    self.uc.mem_write(lpFilename, bytes(self.drivename.encode()))
    fname = self.uc.mem_read(lpFilename, 1000).split(b'\x00')[0].decode() 
    ret = len(self.drivename)
    clean_stack(self, len(args))
    return ret, 'hModule=' + hex(hModule) + ', lpFilename="' + fname + '", nSize=' + hex(nSize)


def EnterCriticalSection(self, args):
    lpCriticalSection = int(args[0], 16)
    clean_stack(self, len(args))
    return None, 'lpCriticalSection=' + hex(lpCriticalSection)


def htons(self, args):
    hostshort = int(args[0], 16)
    clean_stack(self, len(args))
    byte_net = sock.htons(hostshort)
    return byte_net, 'hostshort=' + str(int(hostshort))


def connect(self, args):
    s = int(args[0], 16)
    name = int(args[1], 16)
    namelen = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 's=' + hex(s) + ', name=' + hex(name) + ', namelen=' + hex(namelen)


def InetPtonW(self, args):
    familly = int(args[0], 16)
    pszAddrString = int(args[1], 16)
    pAddrBuf = int(args[2], 16)
    clean_stack(self, len(args))
    return None, 'familly=' + hex(familly) + ', pszAddrString=' + hex(pszAddrString) + ', pAddrBuf=' + hex(pAddrBuf)


def CreateFileA(self, args):
    lpFileName = int(args[0], 16)
    dwDesiredAccess = int(args[1], 16)
    dwShareMode = int(args[2], 16)
    lpSecurityAttributes = int(args[3], 16)
    dwCreationDisposition = int(args[4], 16)
    dwFlagsAndAttributes = int(args[5], 16)
    hTemplateFile = int(args[6], 16)
    
    fname = self.uc.mem_read(lpFileName, 1000).split(b'\x00')[0].decode() 

    if dwShareMode == 0:
        share = 'BLOCK_MODE'
    elif dwShareMode == 1:
        share = 'FILE_SHARE_READ'
    elif dwShareMode == 2:
        share = 'FILE_SHARE_WRITE'
    elif dwShareMode == 4:
        share = 'FILE_SHARE_DELETE'

    if dwCreationDisposition == 1:
        creation = 'CREATE_NEW'
    if dwCreationDisposition == 2:
        creation = 'CREATE_ALWAYS'
    if dwCreationDisposition == 3:
        creation = 'OPEN_EXISTING'
    if dwCreationDisposition == 4:
        creation = 'OPEN_ALWAYS'
    if dwCreationDisposition == 5:
        creation = 'TRUNCATE_EXISTING'

    clean_stack(self, len(args))
    ret = add_handler(self, 'file', fname)
    #ret = 0xffffffff
    return ret, 'lpFileName="' + fname + '", ' + 'dwDesiredAccess=' + hex(dwDesiredAccess) + ', ' + 'dwShareMode=' + share + ', ' + 'lpSecurityAttributes=' + hex(lpSecurityAttributes) + ', ' + 'dwCreationDisposition=' + creation + ', ' + 'dwFlagsAndAttributes=' + hex(dwFlagsAndAttributes) + ', ' + 'hTemplateFile=' + hex(hTemplateFile)


def CloseHandle(self, args):
    hObject = int(args[0], 16)
    val = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x2, 'hObject="' + val


def CloseServiceHandle(self, args):
    hSCObject = int(args[0], 16)
    val = get_handler(self, args[0])
    clean_stack(self, len(args))
    return 0x2, 'hSCObject="' + val


def ExitProcess(self, args):
    uExitCode = int(args[0], 16)
    return 0xdeadbade, 'EXIT'

